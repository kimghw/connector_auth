#!/usr/bin/env python3
"""
MCP Server Scaffold Generator
Creates complete MCP server project structure with all necessary files
"""
import os
import json
from pathlib import Path
from typing import Dict, Any, Optional
from jinja2 import Environment, FileSystemLoader
import shutil


class MCPServerScaffold:
    """Generator for creating new MCP server projects"""

    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.jinja_dir = self.project_root / "jinja"
        self.mcp_editor_dir = self.project_root / "mcp_editor"

        # Setup Jinja2
        self.env = Environment(
            loader=FileSystemLoader(str(self.jinja_dir)),
            trim_blocks=True,
            lstrip_blocks=True
        )

    def create_server_project(
        self,
        server_name: str,
        description: str = "",
        port: int = 8080,
        create_venv: bool = True
    ) -> Dict[str, Any]:
        """
        Create a complete MCP server project structure

        Args:
            server_name: Name of the server (e.g., "outlook", "file_handler")
            description: Server description
            port: Default port for the server
            create_venv: Whether to create a virtual environment

        Returns:
            Dictionary with created paths and status
        """
        print(f"[START] Creating MCP server project: {server_name}")
        print("=" * 60)

        result = {
            "server_name": server_name,
            "created_files": [],
            "created_dirs": [],
            "errors": []
        }

        try:
            # 1. Create main directory structure
            server_dir = self.project_root / f"mcp_{server_name}"
            mcp_server_dir = server_dir / "mcp_server"
            backups_dir = mcp_server_dir / "backups"

            for directory in [server_dir, mcp_server_dir, backups_dir]:
                directory.mkdir(parents=True, exist_ok=True)
                result["created_dirs"].append(str(directory))
                print(f"[OK] Created directory: {directory}")

            # 2. Create __init__.py for mcp_server
            init_file = mcp_server_dir / "__init__.py"
            init_content = f'''"""MCP server module for {server_name}."""

from .server import app
from .tool_definitions import MCP_TOOLS

__all__ = ['app', 'MCP_TOOLS']
'''
            init_file.write_text(init_content)
            result["created_files"].append(str(init_file))
            print(f"[OK] Created: {init_file}")

            # 3. Create server.py from template
            server_template = self.env.get_template("mcp_server_scaffold_template.jinja2")
            server_content = server_template.render(
                server_name=server_name,
                description=description or f"MCP server for {server_name}",
                port=port
            )
            server_file = mcp_server_dir / "server.py"
            server_file.write_text(server_content)
            result["created_files"].append(str(server_file))
            print(f"[OK] Created: {server_file}")

            # 4. Create empty tool_definitions.py
            tool_defs_content = '''"""
MCP Tool Definitions - Clean version for MCP protocol
This file is automatically generated by the MCP Tool Editor
"""

from typing import List, Dict, Any

MCP_TOOLS: List[Dict[str, Any]] = [
    # Tools will be added via the web editor
]
'''
            tool_defs_file = mcp_server_dir / "tool_definitions.py"
            tool_defs_file.write_text(tool_defs_content)
            result["created_files"].append(str(tool_defs_file))
            print(f"[OK] Created: {tool_defs_file}")

            # 5. Copy mcp_decorators.py from reference
            reference_decorators = self.project_root / "mcp_outlook" / "mcp_server" / "mcp_decorators.py"
            if reference_decorators.exists():
                target_decorators = mcp_server_dir / "mcp_decorators.py"
                shutil.copy2(reference_decorators, target_decorators)
                result["created_files"].append(str(target_decorators))
                print(f"[OK] Copied: {target_decorators}")

            # 6. Create run.py
            run_content = f'''#!/usr/bin/env python3
"""
Run script for {server_name} MCP server
"""
import uvicorn

if __name__ == "__main__":
    uvicorn.run(
        "server:app",
        host="0.0.0.0",
        port={port},
        reload=True,
        log_level="info"
    )
'''
            run_file = mcp_server_dir / "run.py"
            run_file.write_text(run_content)
            run_file.chmod(0o755)
            result["created_files"].append(str(run_file))
            print(f"[OK] Created: {run_file}")

            # 7. Create README.md
            readme_content = f'''# MCP {server_name.title()} Server

{description or f"MCP server for {server_name}"}

## Setup

```bash
cd mcp_{server_name}/mcp_server
python -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate
pip install fastapi uvicorn pydantic
```

## Run

```bash
./run.py
# or
python run.py
```

## Edit Tools

```bash
cd ../../mcp_editor
./run_tool_editor.sh
# Select "{server_name}" profile in the web editor
```

## Generated Files

- `server.py`: Main FastAPI server (auto-generated from template)
- `tool_definitions.py`: MCP tool definitions (edited via web editor)
- `run.py`: Server startup script
'''
            readme_file = mcp_server_dir / "README.md"
            readme_file.write_text(readme_content)
            result["created_files"].append(str(readme_file))
            print(f"[OK] Created: {readme_file}")

            # 8. Create tool_definition templates in mcp_editor
            templates_content = f'''"""
MCP Tool Definition Templates for {server_name}
AUTO-GENERATED FILE - Edit via MCP Tool Editor

This file contains tool definitions with metadata for template generation.
"""

from typing import List, Dict, Any

MCP_TOOLS: List[Dict[str, Any]] = [
    # Add your tools here via the web editor
    # Example:
    # {{
    #     "name": "example_tool",
    #     "description": "Example tool description",
    #     "inputSchema": {{
    #         "type": "object",
    #         "properties": {{}},
    #         "required": []
    #     }},
    #     "mcp_service": {{
    #         "name": "example_function",
    #         "signature": "arg1: str, arg2: int"
    #     }}
    # }}
]
'''
            templates_file = self.mcp_editor_dir / f"tool_definition_{server_name}_templates.py"
            templates_file.write_text(templates_content)
            result["created_files"].append(str(templates_file))
            print(f"[OK] Created: {templates_file}")

            # 9. Update editor_config.json
            self._update_editor_config(server_name, port)
            print(f"[OK] Updated editor_config.json")

            # 10. Create basic Jinja2 template for server generation
            self._create_server_template(server_name)
            print(f"[OK] Created Jinja2 template")

            print("\n" + "=" * 60)
            print(f"[OK] Successfully created MCP server: {server_name}")
            print(f"\nNext steps:")
            print(f"  1. cd mcp_{server_name}/mcp_server")
            print(f"  2. python -m venv venv && source venv/bin/activate")
            print(f"  3. pip install fastapi uvicorn pydantic")
            print(f"  4. Edit tools via: cd ../../mcp_editor && ./run_tool_editor.sh")
            print(f"  5. Select '{server_name}' profile in web editor")

        except Exception as e:
            error_msg = f"Error creating server: {str(e)}"
            result["errors"].append(error_msg)
            print(f"\n[ERROR] {error_msg}")
            raise

        return result

    def _update_editor_config(self, server_name: str, port: int):
        """Update editor_config.json with new server profile"""
        config_file = self.mcp_editor_dir / "editor_config.json"

        if config_file.exists():
            with open(config_file, 'r') as f:
                config = json.load(f)
        else:
            config = {"_default": {}}

        # Add new server profile
        config[server_name] = {
            "template_definitions_path": f"tool_definition_{server_name}_templates.py",
            "tool_definitions_path": f"../mcp_{server_name}/mcp_server/tool_definitions.py",
            "backup_dir": "backups",
            "graph_types_files": [],
            "host": "0.0.0.0",
            "port": port + 10  # Web editor port offset
        }

        # Backup existing config
        if config_file.exists():
            backup_file = config_file.with_suffix('.json.backup')
            shutil.copy2(config_file, backup_file)

        # Write updated config
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)

    def _create_server_template(self, server_name: str):
        """Create a Jinja2 template for server.py generation"""
        template_file = self.jinja_dir / f"{server_name}_server_template.jinja2"

        # Copy from scaffold template as base
        scaffold_template = self.jinja_dir / "mcp_server_scaffold_template.jinja2"
        if scaffold_template.exists():
            shutil.copy2(scaffold_template, template_file)

        return template_file


def main():
    """CLI entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="Create new MCP server project")
    parser.add_argument("server_name", help="Name of the server (e.g., 'outlook', 'calendar')")
    parser.add_argument("--description", "-d", default="", help="Server description")
    parser.add_argument("--port", "-p", type=int, default=8080, help="Default server port")
    parser.add_argument("--no-venv", action="store_true", help="Don't create virtual environment")

    args = parser.parse_args()

    # Get project root (parent of jinja directory)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    # Create scaffold
    generator = MCPServerScaffold(str(project_root))
    result = generator.create_server_project(
        server_name=args.server_name,
        description=args.description,
        port=args.port,
        create_venv=not args.no_venv
    )

    if result["errors"]:
        print("\n[WARN]  Some errors occurred:")
        for error in result["errors"]:
            print(f"  - {error}")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
