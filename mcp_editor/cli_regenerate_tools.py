#!/usr/bin/env python3
"""
Regenerate tool_definitions.py from @mcp_service decorated functions in source code.

This script scans the codebase for @mcp_service decorators and automatically
generates tool_definitions.py with basic schemas inferred from function signatures.
"""

import json
import os
import sys
from pathlib import Path
from mcp_service_scanner import scan_codebase_for_mcp_services


def type_to_schema(type_str):
    """Convert Python type annotation to JSON Schema type"""
    if not type_str:
        return {"type": "string"}

    type_str = str(type_str)

    if type_str == 'str':
        return {"type": "string"}
    elif type_str == 'int':
        return {"type": "integer"}
    elif type_str == 'bool':
        return {"type": "boolean"}
    elif type_str == 'float':
        return {"type": "number"}
    elif 'List[' in type_str or 'list[' in type_str:
        return {"type": "array", "items": {"type": "string"}}
    elif 'Dict[' in type_str or 'dict[' in type_str:
        return {"type": "object"}
    else:
        return {"type": "string"}


def generate_tool_definitions(server_name, base_dir):
    """Generate tool_definitions.py from source code"""

    print(f"\n{'='*60}")
    print(f"Regenerating tool_definitions.py for {server_name}")
    print(f"{'='*60}\n")

    # Scan for @mcp_service decorated functions
    services = scan_codebase_for_mcp_services(base_dir, server_name)

    if not services:
        print(f"❌ No @mcp_service decorated functions found in {base_dir}")
        return False

    print(f"✓ Found {len(services)} services:\n")

    # Build tool definitions
    tools = []
    for svc_name, svc_info in sorted(services.items(), key=lambda x: x[0]):
        metadata = svc_info['metadata']
        tool_name = metadata.get('tool_name', svc_name)

        print(f"  • {tool_name} ({svc_name})")

        # Build inputSchema from parameters
        properties = {}
        required = []

        for param in svc_info.get('parameters', []):
            param_name = param['name']

            # Skip special parameters
            if param_name in ('self', 'cls'):
                continue
            if param_name.startswith('**') or param_name.startswith('*'):
                continue

            # Convert type to schema
            properties[param_name] = type_to_schema(param.get('type'))

            # Add to required if no default value
            if param.get('is_required', False):
                required.append(param_name)

        # Create tool definition
        tool = {
            "name": tool_name,
            "description": metadata.get('description', f"{tool_name} function"),
            "inputSchema": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }

        tools.append(tool)

    # Write tool_definitions.py
    output_path = Path(base_dir) / "mcp_server" / "tool_definitions.py"

    content = f'''"""
MCP Tool Definitions for {server_name.title()} Server - AUTO-GENERATED FILE
DO NOT EDIT THIS FILE MANUALLY!

Generated from @mcp_service decorated functions in source code.
To regenerate: python mcp_editor/regenerate_tools.py {server_name}
"""

from typing import List, Dict, Any

# MCP Tool Definitions
MCP_TOOLS: List[Dict[str, Any]] = {json.dumps(tools, indent=4, ensure_ascii=False)}


def get_tool_by_name(tool_name: str) -> Dict[str, Any] | None:
    """Get a specific tool definition by name"""
    for tool in MCP_TOOLS:
        if tool["name"] == tool_name:
            return tool
    return None


def get_tool_names() -> List[str]:
    """Get list of all available tool names"""
    return [tool["name"] for tool in MCP_TOOLS]
'''

    # Create backup of existing file
    if output_path.exists():
        backup_path = output_path.with_suffix('.py.backup')
        import shutil
        shutil.copy2(output_path, backup_path)
        print(f"\n✓ Backed up existing file to: {backup_path.name}")

    output_path.write_text(content, encoding='utf-8')

    print(f"\n{'='*60}")
    print(f"✓ Generated: {output_path}")
    print(f"  Total tools: {len(tools)}")
    print(f"{'='*60}\n")

    return True


def main():
    if len(sys.argv) < 2:
        print("Usage: python regenerate_tools.py <server_name>")
        print("\nExample:")
        print("  python regenerate_tools.py file_handler")
        print("  python regenerate_tools.py outlook")
        sys.exit(1)

    server_name = sys.argv[1]
    base_dir = f"/home/kimghw/Connector_auth/mcp_{server_name}"

    if not os.path.exists(base_dir):
        print(f"❌ Error: Directory not found: {base_dir}")
        sys.exit(1)

    success = generate_tool_definitions(server_name, base_dir)

    if success:
        print("✅ Success! You can now open the web editor to view/edit the tools.")
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
