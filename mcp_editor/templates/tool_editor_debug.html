<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Tool Definitions Editor (DEBUG)</title>
    <style>
        /* Minimal styling for debug version */
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .brand-badges {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-right: 10px;
        }

        .brand-logo {
            width: 22px;
            height: 22px;
            display: inline-block;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
        }
        .tool-list {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 20px;
            background: #fafafa;
        }
        .tool-item {
            padding: 12px;
            margin: 8px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        .tool-item:hover {
            background: #f0f0f0;
        }
        .tool-item.active {
            background: #0071e3;
            color: white;
        }
        #debug-console {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .debug-log {
            margin: 3px 0;
        }
        .debug-log.error {
            color: #ff6b6b;
        }
        .debug-log.success {
            color: #51cf66;
        }
        .debug-log.info {
            color: #74c0fc;
        }

        .btn-debug-active {
            background: #111827;
            color: #ffffff;
        }

        .debug-index-toggle {
            position: relative;
        }

        .debug-dup-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            border-radius: 999px;
            background: #ef4444;
            color: #ffffff;
            font-size: 10px;
            font-weight: 700;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .debug-dup-badge.visible {
            display: inline-flex;
        }

        #debug-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        body.debug-indexes #debug-overlay {
            display: block;
        }

        .debug-id-label {
            position: fixed;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.3px;
            color: #fff;
            background: #1d4ed8;
            box-shadow: 0 4px 10px rgba(0,0,0,0.18);
            white-space: nowrap;
            pointer-events: none;
        }

        .debug-id-label.field {
            background: #0f766e;
        }

        #debug-tooltip {
            position: fixed;
            max-width: 280px;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.4;
            color: #fff;
            background: rgba(20, 20, 23, 0.95);
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
            white-space: pre-line;
            pointer-events: none;
            z-index: 10000;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <span class="brand-badges" aria-label="MCP, Claude, OpenAI, Gemini">
                <img class="brand-logo" src="/static/brands/mcp.svg" alt="MCP" title="MCP" />
                <img class="brand-logo" src="/static/brands/claude.svg" alt="Claude" title="Claude" />
                <img class="brand-logo" src="/static/brands/openai.svg" alt="OpenAI" title="OpenAI" />
                <img class="brand-logo" src="/static/brands/gemini.svg" alt="Gemini" title="Gemini" />
            </span>
            MCP Tool Definitions Editor (DEBUG MODE)
        </h1>

        <div>
            <button data-debug-id="DBG_RELOAD" onclick="loadTools()" style="padding: 10px 20px; margin-right: 10px;">Reload Tools</button>
            <button data-debug-id="DBG_CLEAR" onclick="clearDebugConsole()" style="padding: 10px 20px; margin-right: 10px;">Clear Console</button>
            <button class="debug-index-toggle" data-debug-id="DBG_IDS" id="debugIndexToggle" onclick="toggleDebugIndexes()" style="padding: 10px 20px;">
                IDs
                <span class="debug-dup-badge" id="debugDuplicateBadge" aria-hidden="true"></span>
            </button>
        </div>

        <h2>Tool List</h2>
        <div class="tool-list">
            <div id="toolList">
                <em>No tools loaded yet...</em>
            </div>
        </div>

        <h2>Debug Console</h2>
        <div id="debug-console">
            <div class="debug-log info">Debug console initialized...</div>
        </div>
    </div>

    <script>
        let tools = [];
        let currentToolIndex = -1;
        let debugIndexEnabled = false;
        let debugIndexObserver = null;
        let debugIndexRefreshPending = false;

        // Debug logging function
        function debugLog(message, type = 'info') {
            const console = document.getElementById('debug-console');
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            const logEntry = document.createElement('div');
            logEntry.className = `debug-log ${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            console.appendChild(logEntry);
            console.scrollTop = console.scrollHeight;

            // Also log to browser console
            window.console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearDebugConsole() {
            document.getElementById('debug-console').innerHTML =
                '<div class="debug-log info">Debug console cleared...</div>';
        }

        // Load tools on page load
        window.onload = function() {
            debugLog('Page loaded, window.onload triggered', 'info');
            debugLog('Calling loadTools()...', 'info');
            loadTools();
            initDebugIndexing();
        };

        function loadTools() {
            debugLog('loadTools() function called', 'info');
            debugLog('Fetching from /api/tools...', 'info');

            fetch('/api/tools')
                .then(response => {
                    debugLog(`Response received: status=${response.status}, ok=${response.ok}`, 'success');
                    debugLog(`Content-Type: ${response.headers.get('Content-Type')}`, 'info');
                    return response.json();
                })
                .then(data => {
                    debugLog('JSON parsing successful', 'success');
                    debugLog(`Data type: ${typeof data}, isArray: ${Array.isArray(data)}`, 'info');
                    debugLog(`Number of tools: ${data.length}`, 'info');

                    // Log each tool
                    data.forEach((tool, index) => {
                        debugLog(`  Tool ${index}: name="${tool.name}", description="${tool.description}"`, 'info');
                    });

                    // Set global tools variable
                    tools = data;
                    debugLog(`Global tools variable set, tools.length = ${tools.length}`, 'success');

                    // Call renderToolList
                    debugLog('Calling renderToolList()...', 'info');
                    renderToolList();
                    debugLog('renderToolList() completed', 'success');
                })
                .catch(error => {
                    debugLog(`ERROR in loadTools(): ${error.message}`, 'error');
                    debugLog(`Error stack: ${error.stack}`, 'error');
                    console.error('Error loading tools:', error);
                });
        }

        function renderToolList() {
            debugLog('--- renderToolList() START ---', 'info');
            debugLog(`tools array length: ${tools.length}`, 'info');
            debugLog(`currentToolIndex: ${currentToolIndex}`, 'info');

            const toolList = document.getElementById('toolList');
            if (!toolList) {
                debugLog('ERROR: toolList element not found in DOM!', 'error');
                return;
            }
            debugLog('toolList element found', 'success');

            debugLog('Clearing toolList.innerHTML...', 'info');
            toolList.innerHTML = '';
            debugLog('toolList cleared', 'success');

            debugLog('Starting forEach loop...', 'info');
            tools.forEach((tool, index) => {
                debugLog(`  Creating element for tool ${index}: ${tool.name}`, 'info');

                const toolItem = document.createElement('div');
                toolItem.className = 'tool-item';

                if (index === currentToolIndex) {
                    toolItem.classList.add('active');
                    debugLog(`    Tool ${index} is active`, 'info');
                }

                toolItem.onclick = () => selectTool(index);

                toolItem.innerHTML = `
                    <h3 style="margin: 0 0 5px 0; font-size: 16px;">${tool.name}</h3>
                    <p style="margin: 0; font-size: 14px; color: #666;">${tool.description}</p>
                `;

                debugLog(`    Appending tool ${index} to DOM...`, 'info');
                toolList.appendChild(toolItem);
                debugLog(`    Tool ${index} appended successfully`, 'success');
            });

            debugLog(`forEach loop completed, processed ${tools.length} tools`, 'success');
            debugLog('--- renderToolList() END ---', 'info');
        }

        function selectTool(index) {
            debugLog(`selectTool(${index}) called`, 'info');
            currentToolIndex = index;
            debugLog(`currentToolIndex set to ${currentToolIndex}`, 'info');
            debugLog(`Selected tool: ${tools[index].name}`, 'success');
            renderToolList();
        }

        function initDebugIndexing() {
            ensureDebugOverlay();
            const saved = localStorage.getItem('mcp_debug_indexes') === '1';
            setDebugIndexState(saved);

            document.addEventListener('scroll', queueDebugIndexRefresh, true);
            window.addEventListener('resize', queueDebugIndexRefresh);
            document.addEventListener('mousemove', updateDebugTooltip);
        }

        function toggleDebugIndexes() {
            setDebugIndexState(!debugIndexEnabled);
        }

        function setDebugIndexState(enabled) {
            debugIndexEnabled = enabled;
            document.body.classList.toggle('debug-indexes', enabled);
            localStorage.setItem('mcp_debug_indexes', enabled ? '1' : '0');

            const toggle = document.getElementById('debugIndexToggle');
            if (toggle) {
                toggle.classList.toggle('btn-debug-active', enabled);
            }

            if (enabled) {
                queueDebugIndexRefresh();
            } else {
                const overlay = document.getElementById('debug-overlay');
                if (overlay) {
                    overlay.innerHTML = '';
                }
                hideDebugTooltip();
                updateDebugDuplicateBadge(0);
            }
        }

        function ensureDebugOverlay() {
            let overlay = document.getElementById('debug-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'debug-overlay';
                document.body.appendChild(overlay);
            }

            let tooltip = document.getElementById('debug-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'debug-tooltip';
                document.body.appendChild(tooltip);
            }

            if (!debugIndexObserver) {
                debugIndexObserver = new MutationObserver(() => {
                    queueDebugIndexRefresh();
                });
                debugIndexObserver.observe(document.body, { childList: true, subtree: true });
            }

            return overlay;
        }

        function queueDebugIndexRefresh() {
            if (!debugIndexEnabled || debugIndexRefreshPending) {
                return;
            }

            debugIndexRefreshPending = true;
            requestAnimationFrame(() => {
                debugIndexRefreshPending = false;
                refreshDebugIndexes();
            });
        }

        function refreshDebugIndexes() {
            if (!debugIndexEnabled) {
                return;
            }

            const overlay = ensureDebugOverlay();
            overlay.innerHTML = '';

            const targets = getDebugTargets();
            const usedIds = new Set();
            const idCounts = new Map();
            const buttonCounter = { value: 1 };
            const fieldCounter = { value: 1 };

            targets.buttons.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('', usedIds, buttonCounter);
                registerDebugId(labelText, usedIds, idCounts, target);
                addDebugLabel(overlay, target, labelText, 'button', isAuto);
            });

            targets.fields.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('f', usedIds, fieldCounter);
                registerDebugId(labelText, usedIds, idCounts, target);
                addDebugLabel(overlay, target, labelText, 'field', isAuto);
            });

            const duplicateCount = Array.from(idCounts.values()).filter(count => count > 1).length;
            updateDebugDuplicateBadge(duplicateCount);
        }

        function getDebugTargets() {
            const buttons = Array.from(document.querySelectorAll('button')).filter(isValidDebugTarget);
            const fields = Array.from(document.querySelectorAll('input, textarea, select'))
                .filter(isTextLikeInput)
                .filter(isValidDebugTarget);
            const manualTargets = Array.from(document.querySelectorAll('[data-debug-id]')).filter(isValidDebugTarget);
            const buttonSet = new Set(buttons);
            const fieldSet = new Set(fields);

            manualTargets.forEach(target => {
                if (buttonSet.has(target) || fieldSet.has(target)) {
                    return;
                }

                const tag = target.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') {
                    fields.push(target);
                    fieldSet.add(target);
                } else {
                    buttons.push(target);
                    buttonSet.add(target);
                }
            });

            return { buttons, fields };
        }

        function getExplicitDebugId(target) {
            const manualId = target.getAttribute('data-debug-id');
            if (manualId && manualId.trim() && target.getAttribute('data-debug-auto') !== '1') {
                return manualId.trim();
            }

            const legacyId = target.getAttribute('data-fixed-debug-id');
            if (legacyId && legacyId.trim()) {
                return legacyId.trim();
            }

            return null;
        }

        function registerDebugId(labelText, usedIds, idCounts, target) {
            if (usedIds.has(labelText)) {
                console.warn(`[DebugIndex] Duplicate data-debug-id "${labelText}"`, target);
            }
            usedIds.add(labelText);
            idCounts.set(labelText, (idCounts.get(labelText) || 0) + 1);
        }

        function updateDebugDuplicateBadge(duplicateCount) {
            const badge = document.getElementById('debugDuplicateBadge');
            if (!badge) {
                return;
            }

            if (duplicateCount > 0) {
                badge.textContent = String(duplicateCount);
                badge.classList.add('visible');
                badge.setAttribute('aria-label', `Duplicate debug IDs: ${duplicateCount}`);
            } else {
                badge.textContent = '';
                badge.classList.remove('visible');
                badge.removeAttribute('aria-label');
            }
        }

        function getNextAutoDebugId(prefix, usedIds, counterRef) {
            let candidate = '';
            do {
                candidate = `${prefix}${counterRef.value}`;
                counterRef.value += 1;
            } while (usedIds.has(candidate));
            return candidate;
        }

        function isTextLikeInput(el) {
            if (!el || !el.tagName) {
                return false;
            }

            if (el.tagName === 'TEXTAREA' || el.tagName === 'SELECT') {
                return true;
            }

            if (el.tagName !== 'INPUT') {
                return false;
            }

            const type = (el.getAttribute('type') || 'text').toLowerCase();
            return !['checkbox', 'radio', 'button', 'submit', 'reset', 'hidden', 'image', 'file', 'range', 'color'].includes(type);
        }

        function isValidDebugTarget(el) {
            if (!el || !(el instanceof Element)) {
                return false;
            }

            if (el.closest('#debug-overlay') || el.closest('#debug-tooltip')) {
                return false;
            }

            if (el.hasAttribute('data-debug-skip') || el.closest('[data-debug-skip="true"]')) {
                return false;
            }

            return true;
        }

        function addDebugLabel(overlay, target, labelText, kind, isAuto) {
            if (!target || !labelText) {
                return;
            }

            if (isAuto) {
                target.setAttribute('data-debug-auto', '1');
                target.setAttribute('data-debug-auto-id', labelText);
                target.removeAttribute('data-debug-id');
            } else {
                target.removeAttribute('data-debug-auto');
                target.removeAttribute('data-debug-auto-id');
                target.setAttribute('data-debug-id', labelText);
            }

            const actions = getDebugActions(target);
            if (actions.length > 0) {
                target.setAttribute('data-debug-actions', actions.join('\n'));
            } else {
                target.removeAttribute('data-debug-actions');
            }

            const rect = target.getBoundingClientRect();
            if (!isRectVisible(rect)) {
                return;
            }

            const label = document.createElement('div');
            label.className = `debug-id-label ${kind}`;
            label.textContent = labelText;
            overlay.appendChild(label);
            positionDebugLabel(label, rect);
        }

        function getDebugActions(target) {
            const attributes = [
                'onclick',
                'onchange',
                'oninput',
                'onkeyup',
                'onkeydown',
                'onfocus',
                'onblur',
                'onmouseenter',
                'onmouseleave',
                'onmouseover',
                'onmouseout'
            ];

            const actions = [];
            attributes.forEach(attr => {
                const value = target.getAttribute(attr);
                if (value) {
                    actions.push(`${attr}: ${value.trim().replace(/\s+/g, ' ')}`);
                }
            });

            return actions;
        }

        function isRectVisible(rect) {
            if (!rect) {
                return false;
            }

            if (rect.width < 1 && rect.height < 1) {
                return false;
            }

            return !(rect.bottom < 0 || rect.right < 0 || rect.top > window.innerHeight || rect.left > window.innerWidth);
        }

        function positionDebugLabel(label, rect) {
            const offset = 4;
            let left = rect.left + offset;
            let top = rect.top + offset;

            label.style.left = `${left}px`;
            label.style.top = `${top}px`;

            const labelRect = label.getBoundingClientRect();
            if (labelRect.right > window.innerWidth - 4) {
                left = window.innerWidth - labelRect.width - 4;
            }
            if (labelRect.bottom > window.innerHeight - 4) {
                top = window.innerHeight - labelRect.height - 4;
            }

            label.style.left = `${Math.max(4, left)}px`;
            label.style.top = `${Math.max(4, top)}px`;
        }

        function updateDebugTooltip(event) {
            if (!debugIndexEnabled) {
                hideDebugTooltip();
                return;
            }

            const target = event.target instanceof Element
                ? event.target.closest('[data-debug-id], [data-debug-auto-id]')
                : null;
            if (!target) {
                hideDebugTooltip();
                return;
            }

            const actions = target.getAttribute('data-debug-actions');
            if (!actions) {
                hideDebugTooltip();
                return;
            }

            const tooltip = document.getElementById('debug-tooltip');
            if (!tooltip) {
                return;
            }

            tooltip.textContent = actions;
            tooltip.style.display = 'block';

            let left = event.clientX + 12;
            let top = event.clientY + 12;

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;

            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth - 8) {
                left = window.innerWidth - rect.width - 8;
            }
            if (rect.bottom > window.innerHeight - 8) {
                top = window.innerHeight - rect.height - 8;
            }

            tooltip.style.left = `${Math.max(8, left)}px`;
            tooltip.style.top = `${Math.max(8, top)}px`;
        }

        function hideDebugTooltip() {
            const tooltip = document.getElementById('debug-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
                tooltip.textContent = '';
            }
        }

        // Log initial state
        debugLog('Script loaded, initial state:', 'info');
        debugLog(`  tools.length = ${tools.length}`, 'info');
        debugLog(`  currentToolIndex = ${currentToolIndex}`, 'info');
    </script>
</body>
</html>
