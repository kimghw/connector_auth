<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP Tool Definitions Editor</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary-color: #0071e3;
            --primary-hover: #0077ed;
            --danger-color: #ff3b30;
            --danger-hover: #ff453a;
            --success-color: #34c759;
            --warning-color: #ff9f0a;
            --bg-color: #f5f5f7;
            --card-bg: #ffffff;
            --sidebar-bg: #ffffff;
            --border-color: #d2d2d7;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;
            --shadow-sm: 0 2px 5px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-lg: 0 12px 30px rgba(0,0,0,0.12);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 18px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
        }

        .header {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: saturate(180%) blur(20px);
            -webkit-backdrop-filter: saturate(180%) blur(20px);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand-logos {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .brand-logo {
            height: 32px;
            width: auto;
            display: inline-block;
            border-radius: 4px;
            object-fit: contain;
        }

        .gradient-text {
            background: linear-gradient(135deg, #c084fc 0%, #60a5fa 40%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-buttons {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 980px; /* Pill shape */
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
        }

        .btn-icon-only {
            padding: 0;
            width: 36px;
            height: 36px;
            justify-content: center;
            border-radius: 50%;
        }

        .btn-expandable {
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .btn-expandable .btn-text {
            max-width: 0;
            overflow: hidden;
            white-space: nowrap;
            transition: max-width 0.3s ease, margin-left 0.3s ease;
            margin-left: 0;
        }

        .btn-expandable:hover .btn-text {
            max-width: 100px;
            margin-left: 6px;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: scale(1.02);
        }

        .btn-secondary {
            background: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background: var(--danger-hover);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-success:hover {
            background: #30b350;
        }

        .btn-success:disabled {
            background: #86868b;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-warning:hover {
            background: #ff9500;
        }

        .btn-warning:disabled {
            background: #86868b;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-danger:disabled {
            background: #86868b;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-important {
            background: linear-gradient(135deg, #34c759 0%, #30b350 100%);
            color: white;
            font-weight: 600;
            padding: 10px 24px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .btn-important:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(52, 199, 89, 0.4);
            filter: brightness(1.05);
        }

        /* Tooltip styles */
        .btn-tooltip {
            position: relative;
        }

        .btn-tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            background: rgba(20, 20, 23, 0.95);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            white-space: pre-line;
            text-align: center;
            line-height: 1.4;
            min-width: max-content;
            max-width: 280px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255,255,255,0.1);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            z-index: 1000;
        }

        .btn-tooltip::before {
            content: '';
            position: absolute;
            top: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%) translateY(-4px);
            border: 6px solid transparent;
            border-bottom-color: rgba(20, 20, 23, 0.95);
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            z-index: 1000;
        }

        .btn-tooltip:hover::after,
        .btn-tooltip:hover::before {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .btn-debug-active {
            background: #111827;
            color: #ffffff;
        }

        .btn-debug-active:hover {
            background: #0f172a;
        }

        .debug-index-toggle {
            position: relative;
        }

        .debug-dup-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            border-radius: 999px;
            background: #ef4444;
            color: #ffffff;
            font-size: 10px;
            font-weight: 700;
            display: none;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .debug-dup-badge.visible {
            display: inline-flex;
        }

        /* Debug index overlay */
        #debug-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        body.debug-indexes #debug-overlay {
            display: block;
        }

        .debug-id-label {
            position: fixed;
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.3px;
            color: #fff;
            background: #1d4ed8;
            box-shadow: 0 4px 10px rgba(0,0,0,0.18);
            white-space: nowrap;
            pointer-events: none;
        }

        .debug-id-label.field {
            background: #0f766e;
        }

        .debug-id-label.area {
            background: #ff8c00;
        }

        #debug-tooltip {
            position: fixed;
            max-width: 280px;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.4;
            color: #fff;
            background: rgba(20, 20, 23, 0.95);
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
            white-space: pre-line;
            pointer-events: none;
            z-index: 10000;
            display: none;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .tool-list {
            padding: 20px;
            flex: 1;
        }

        .tool-item {
            background: transparent;
            padding: 12px 16px;
            margin-bottom: 4px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .tool-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .tool-item.active {
            background: var(--primary-color);
            color: white;
        }

        .tool-item.active h3,
        .tool-item.active p {
            color: white;
        }

        .tool-item h3 {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .tool-item p {
            font-size: 13px;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .editor-area {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            background-color: #fff;
        }

        .form-group {
            margin-bottom: 24px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 15px;
            transition: all 0.2s;
            background: #fff;
            color: var(--text-primary);
            font-family: inherit;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(0, 113, 227, 0.15);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 120px;
            line-height: 1.5;
        }

        .properties-container {
            background: #fbfbfd;
            padding: 20px;
            border-radius: var(--radius-md);
            margin-top: 16px;
            border: 1px solid var(--border-color);
        }

        .property-item {
            background: white;
            padding: 20px;
            margin-bottom: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }

        .property-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid #f5f5f7;
        }

        .btn-sm {
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 6px;
        }

        .btn-icon {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 6px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-icon:hover {
            background: rgba(0,0,0,0.05);
            color: var(--text-primary);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            animation: fadeIn 0.2s;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-lg);
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            animation: scaleIn 0.2s;
            box-shadow: var(--shadow-lg);
            border: 1px solid rgba(0,0,0,0.1);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255,255,255,0.9);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .modal-header h2, .modal-header h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }

        .close-btn:hover {
            color: #000;
        }

        .modal-body {
            padding: 24px;
        }

        .modal-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            background: #fbfbfd;
        }

        .backup-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .backup-item {
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }

        .backup-info {
            flex: 1;
        }

        .backup-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .backup-date {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 12px 20px;
            border-radius: var(--radius-md);
            color: white;
            font-weight: 500;
            z-index: 2000;
            animation: slideInRight 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: var(--shadow-md);
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--danger-color);
        }

        .notification.warning {
            background: var(--warning-color);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .json-editor {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: var(--radius-md);
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-x: auto;
            border: 1px solid #333;
        }

        .add-button {
            width: 100%;
            padding: 12px;
            border: 1px dashed var(--primary-color);
            background: rgba(0, 113, 227, 0.05);
            color: var(--primary-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .add-button:hover {
            background: rgba(0, 113, 227, 0.1);
        }

        /* Collapsible sections */
        .collapsible-header {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 8px 12px;
            background: #f0f0f0;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .collapsible-header:hover {
            background: #e8e8e8;
        }

        .collapse-icon {
            margin-right: 8px;
            transition: transform 0.2s;
            font-family: monospace;
            font-size: 16px;
            color: #666;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            display: none;
        }

        .property-collapsible {
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .property-collapse-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .property-collapse-header:hover {
            background: #f7f7ff;
        }

        .property-collapse-header.expanded {
            background: #f7f7ff;
            border-bottom: 1px solid #e5e5e5;
        }

        .property-collapse-content {
            padding: 10px;
            background: #fafafa;
        }

        .property-collapse-content.collapsed {
            display: none;
        }

        .json-viewer {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #d2d2d7;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #86868b;
        }

        /* MCP Server Controller Styles */
        .mcp-controller {
            transition: all 0.3s ease;
        }

        .mcp-controller:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .status-indicator.running {
            background: #28a745;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);
        }

        .status-indicator.stopped {
            background: #dc3545;
            animation: none;
        }

        .status-indicator.checking {
            background: #6c757d;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <img class="brand-logo" src="/static/brands/logo.jpg" alt="Logo" title="Logo" />
                <span>MCP Tool <span class="gradient-text">Editor</span></span>
            </h1>
            <div class="header-buttons">
                <button class="btn btn-secondary btn-tooltip btn-icon-only" data-debug-id="BTN_RELOAD" onclick="loadTools()" data-tooltip="ðŸ“‚ Load: tool_definitions.py&#10;ðŸ“‚ Load: tool_internal_args.json&#10;&#10;Refresh tool list from server files">
                    <span class="material-icons">refresh</span>
                </button>
                <button class="btn btn-secondary btn-tooltip debug-index-toggle btn-icon-only" data-debug-id="BTN_IDS" id="debugIndexToggle" onclick="toggleDebugIndexes()" data-tooltip="Show IDs on buttons/fields and hover to see inline handlers" aria-pressed="false">
                    <span class="material-icons">push_pin</span>
                    <span class="debug-dup-badge" id="debugDuplicateBadge" aria-hidden="true"></span>
                </button>
                <button class="btn btn-secondary btn-tooltip btn-icon-only" data-debug-id="BTN_BACKUPS" onclick="showBackups()" data-tooltip="Manage backups">
                    <span class="material-icons">inventory_2</span>
                </button>
                <button class="btn btn-secondary btn-tooltip btn-icon-only" data-debug-id="BTN_VALIDATE" onclick="validateTools()" data-tooltip="Validate tool definitions">
                    <span class="material-icons">check_circle</span>
                </button>
                <button class="btn btn-secondary btn-tooltip btn-icon-only" data-debug-id="BTN_SAVE" onclick="saveTools()" data-tooltip="ðŸ’¾ Save: tool_definitions.py&#10;ðŸ’¾ Save: tool_definition_templates.py&#10;ðŸ’¾ Save: tool_internal_args.json&#10;&#10;Save all changes to disk">
                    <span class="material-icons">save</span>
                </button>
                <button class="btn btn-important btn-tooltip" data-debug-id="BTN_GENERATE" onclick="saveTools(); openGeneratorModal()" data-tooltip="âš™ï¸ Input: tool_definitions.py&#10;ðŸ“„ Template: *_server_template.jinja2&#10;ðŸš€ Output: server.py&#10;&#10;Generate MCP server from template">
                    <span class="material-icons">auto_fix_high</span> Generate Server
                </button>
                <button class="btn btn-primary btn-tooltip btn-expandable" data-debug-id="BTN_NEW_PROJECT" onclick="openCreateProjectModal()" data-tooltip="ðŸš€ Create new MCP server project&#10;ðŸ“ Complete folder structure&#10;ðŸ“ Ready-to-use templates&#10;&#10;Create a new MCP service from scratch">
                    <span class="material-icons">add_circle</span><span class="btn-text">New Project</span>
                </button>
            </div>
        </div>
        <div id="profileTabs" data-debug-id="AREA_PROFILE_TABS" style="display: flex; justify-content: flex-start; gap: 8px; padding: 10px 20px; background: #f7f7f7; border-bottom: 1px solid #e5e5e5;">
            <!-- Profile tabs will be rendered here -->
        </div>
        <div id="templateSelector" data-debug-id="AREA_TEMPLATE_SELECTOR" style="display: flex; gap: 12px; align-items: center; padding: 8px 20px; background: #fff9e6; border-bottom: 1px solid #e5e5e5;">
            <label style="font-size: 13px; font-weight: 500; color: #666; white-space: nowrap;">
                <span class="material-icons" style="font-size: 16px; vertical-align: middle;">description</span>
                Load Template:
            </label>
            <select id="templateSource" class="form-control" data-debug-id="FIELD_TEMPLATE_SOURCE" style="flex: 1; max-width: 400px; padding: 6px 12px; font-size: 13px;">
                <option value="">-- Current Template --</option>
            </select>
            <button class="btn btn-secondary btn-sm" data-debug-id="BTN_TEMPLATE_LOAD" onclick="loadFromSelectedTemplate()" title="Load tools from selected template">
                <span class="material-icons" style="font-size: 14px;">file_download</span> Load
            </button>
            <span id="templateLoadStatus" style="font-size: 12px; color: #666;"></span>
            <span style="font-size: 11px; color: #999; margin-left: auto;">
                * Save will update: <strong id="saveTargetLabel">current profile</strong>
            </span>
        </div>

        <div class="main-content" data-debug-id="AREA_MAIN_CONTENT">
            <div class="sidebar" data-debug-id="AREA_SIDEBAR">
                <div class="tool-list" data-debug-id="AREA_TOOL_LIST">
                    <!-- MCP Server Controller -->
                    <div class="mcp-controller" data-debug-id="AREA_MCP_CONTROLLER" style="margin-bottom: 20px; padding: 16px; background: white; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.05);">
                        <div style="display: flex; align-items: center; margin-bottom: 16px;">
                            <div style="width: 40px; height: 40px; border-radius: 10px; background: linear-gradient(135deg, #0071e3, #00c6fb); display: flex; align-items: center; justify-content: center; margin-right: 12px; box-shadow: 0 4px 8px rgba(0,113,227,0.2);">
                                <span class="material-icons" style="color: white; font-size: 24px;">dns</span>
                            </div>
                            <div style="flex: 1;">
                                <h3 style="margin: 0; font-size: 15px; font-weight: 600; color: #1d1d1f;">MCP Server</h3>
                                <div id="serverStatus" data-debug-id="LABEL_SERVER_STATUS" style="display: flex; align-items: center; font-size: 12px; margin-top: 2px;">
                                    <span class="status-indicator" id="statusIndicator" style="display: inline-block; width: 6px; height: 6px; border-radius: 50%; background: #86868b; margin-right: 6px;"></span>
                                    <span id="statusText" style="color: #86868b; font-weight: 500;">Checking...</span>
                                </div>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                            <button class="btn btn-sm" data-debug-id="BTN_SERVER_START" id="btnStart" onclick="startServer()" style="background: #e8f5e9; color: #2e7d32; border: none; padding: 6px 4px; border-radius: 8px; font-weight: 600; transition: all 0.2s; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; height: auto;">
                                <span class="material-icons" style="font-size: 20px; margin-bottom: 2px;">play_arrow</span>
                                <span style="font-size: 10px;">Start</span>
                            </button>
                            <button class="btn btn-sm" data-debug-id="BTN_SERVER_STOP" id="btnStop" onclick="stopServer()" style="background: #ffebee; color: #c62828; border: none; padding: 6px 4px; border-radius: 8px; font-weight: 600; transition: all 0.2s; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; height: auto;">
                                <span class="material-icons" style="font-size: 20px; margin-bottom: 2px;">stop</span>
                                <span style="font-size: 10px;">Stop</span>
                            </button>
                            <button class="btn btn-sm" data-debug-id="BTN_SERVER_RESTART" id="btnRestart" onclick="restartServer()" style="background: #fff3e0; color: #ef6c00; border: none; padding: 6px 4px; border-radius: 8px; font-weight: 600; transition: all 0.2s; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; height: auto;">
                                <span class="material-icons" style="font-size: 20px; margin-bottom: 2px;">refresh</span>
                                <span style="font-size: 10px;">Restart</span>
                            </button>
                        </div>

                        <div id="serverInfo" data-debug-id="LABEL_SERVER_INFO" style="font-size: 11px; color: #86868b; background: #f5f5f7; padding: 8px 12px; border-radius: 8px; display: flex; justify-content: space-between;">
                            <div id="profileInfo">
                                <span style="font-weight: 600;">Profile:</span> <span id="profileValue">default</span>
                            </div>
                            <div id="pidInfo" style="display: none;">
                                <span style="font-weight: 600;">PID:</span> <span id="pidValue">-</span>
                            </div>
                        </div>
                    </div>

                    <button class="add-button" data-debug-id="BTN_ADD_TOOL" onclick="addNewTool()">
                        <span class="material-icons">add</span> Add New Tool
                    </button>
                    <div id="toolList" style="margin-top: 15px;">
                        <!-- Tool items will be loaded here -->
                    </div>
                </div>
            </div>

            <div class="editor-area" data-debug-id="AREA_EDITOR">
                <div id="editorContent">
                    <div style="text-align: center; padding: 50px; color: var(--text-secondary);">
                        Select a tool from the left sidebar to edit
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nested Properties Modal -->
    <div id="nestedPropertiesModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 id="nestedModalTitle">Edit Nested Properties</h2>
                <button class="btn btn-icon" data-debug-id="BTN_NESTED_CLOSE" onclick="closeModal('nestedPropertiesModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div id="nestedPropertiesEditor">
                    <!-- Nested properties editor will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" data-debug-id="BTN_NESTED_SAVE" onclick="saveNestedProperties()">Save Properties</button>
                <button class="btn btn-secondary" data-debug-id="BTN_NESTED_CANCEL" onclick="closeModal('nestedPropertiesModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- BaseModel Selector Modal -->
    <div id="baseModelModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Select BaseModel to Import</h2>
                <button class="btn btn-icon" data-debug-id="BTN_BASEMODEL_CLOSE" onclick="closeModal('baseModelModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div id="baseModelList" style="max-height: 500px; overflow-y: auto;">
                    <!-- BaseModel list will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-debug-id="BTN_BASEMODEL_CANCEL" onclick="closeModal('baseModelModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Nested Graph Types Modal -->
    <div id="nestedGraphTypesModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>Add Nested Properties</h2>
                <button class="btn btn-icon" data-debug-id="BTN_NESTED_TYPES_CLOSE" onclick="closeModal('nestedGraphTypesModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Select Type (from outlook_types.py)</label>
                    <select id="nestedGraphTypeClass" data-debug-id="FIELD_NESTED_GRAPH_TYPE" onchange="handleNestedGraphClassChange()" class="form-control">
                        <option value="">-- Select Type --</option>
                        <option value="FilterParams">FilterParams (Filter criteria)</option>
                        <option value="ExcludeParams">ExcludeParams (Exclusion criteria)</option>
                        <option value="SelectParams">SelectParams (Field selection)</option>
                    </select>
                </div>
                <div class="form-group" id="nestedPropertySelectionDiv" style="display: none;">
                    <label>Select Properties to Add</label>
                    <div style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; max-height: 300px; overflow-y: auto;">
                        <div id="nestedPropertyCheckboxList">
                            <!-- Checkboxes will be populated here -->
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <button type="button" class="btn btn-sm btn-secondary" data-debug-id="BTN_NESTED_SELECT_ALL" onclick="selectAllNestedProperties(true)">Select All</button>
                        <button type="button" class="btn btn-sm btn-secondary" data-debug-id="BTN_NESTED_DESELECT_ALL" onclick="selectAllNestedProperties(false)">Deselect All</button>
                        <button type="button" class="btn btn-sm btn-secondary" data-debug-id="BTN_NESTED_ALL_REQUIRED" onclick="toggleAllNestedRequired(true)">All Required</button>
                        <button type="button" class="btn btn-sm btn-secondary" data-debug-id="BTN_NESTED_ALL_OPTIONAL" onclick="toggleAllNestedRequired(false)">All Optional</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" data-debug-id="BTN_NESTED_TYPES_ADD" onclick="confirmAddNestedGraphProperties()">Add Selected</button>
                <button class="btn btn-secondary" data-debug-id="BTN_NESTED_TYPES_CANCEL" onclick="closeModal('nestedGraphTypesModal')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Backup Modal -->
    <div id="backupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Backup Management</h2>
                <button class="btn btn-icon" data-debug-id="BTN_BACKUP_CLOSE_X" onclick="closeModal('backupModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div id="backupList" class="backup-list">
                    <!-- Backup items will be loaded here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-debug-id="BTN_BACKUP_CLOSE" onclick="closeModal('backupModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Create New MCP Project Modal -->
    <div id="createProjectModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>Create New MCP Project</h2>
                <button class="btn btn-icon" data-debug-id="BTN_PROJECT_CLOSE" onclick="closeModal('createProjectModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Service Name <span style="color: red;">*</span></label>
                    <input id="projectServiceName" class="form-control" data-debug-id="FIELD_PROJECT_NAME" placeholder="e.g., calendar, weather, database" required>
                    <p style="margin-top: 6px; color: var(--text-secondary); font-size: 12px;">
                        Only letters, numbers, and underscores allowed. Will create mcp_{service_name} folder.
                    </p>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <input id="projectDescription" class="form-control" data-debug-id="FIELD_PROJECT_DESC" placeholder="Brief description of the service">
                </div>
                <div class="form-group">
                    <label>Port</label>
                    <input id="projectPort" type="number" class="form-control" data-debug-id="FIELD_PROJECT_PORT" value="8080" min="1024" max="65535">
                    <p style="margin-top: 6px; color: var(--text-secondary); font-size: 12px;">
                        Server port number (1024-65535)
                    </p>
                </div>
                <div class="form-group">
                    <label>Author</label>
                    <input id="projectAuthor" class="form-control" data-debug-id="FIELD_PROJECT_AUTHOR" placeholder="Your name (optional)">
                </div>
                <div class="form-group">
                    <label>
                        <input id="projectIncludeTypes" type="checkbox" data-debug-id="FIELD_PROJECT_INCLUDE_TYPES" checked>
                        Include type definitions file (*_types.py)
                    </label>
                </div>
                <div id="createProjectResult" style="margin-top: 15px; padding: 12px; border-radius: 6px; display: none;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" data-debug-id="BTN_PROJECT_CANCEL" onclick="closeModal('createProjectModal')">Cancel</button>
                <button class="btn btn-primary" data-debug-id="BTN_PROJECT_CREATE" onclick="createNewProject()">Create Project</button>
            </div>
        </div>
    </div>

    <!-- Server Generator Modal -->
    <div id="generatorModal" class="modal">
        <div class="modal-content" style="max-width: 760px;">
            <div class="modal-header">
                <h2>Generate MCP Server</h2>
                <button class="btn btn-icon" data-debug-id="BTN_GENERATOR_CLOSE" onclick="closeModal('generatorModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Select Module</label>
                    <select id="generatorModule" class="form-control" data-debug-id="FIELD_GENERATOR_MODULE" onchange="handleGeneratorModuleChange()">
                        <option value="">Custom / Current Profile</option>
                    </select>
                    <p style="margin-top: 6px; color: var(--text-secondary); font-size: 12px;">
                        Detected modules share the same mcp folder layout. Choose one to auto-fill generator args.
                    </p>
                </div>
                <div class="form-group">
                    <label>Tools path (--tools)</label>
                    <div style="display: flex; gap: 8px;">
                        <input id="generatorToolsPath" class="form-control" data-debug-id="FIELD_GENERATOR_TOOLS_PATH" placeholder="/path/to/tool_definition_templates.py" style="flex: 1;">
                        <button class="btn btn-secondary" data-debug-id="BTN_GENERATOR_TOOLS_PICK" onclick="selectFilePath('generatorToolsPath', '.py')" style="padding: 8px 12px;">
                            <span class="material-icons" style="font-size: 18px;">folder_open</span>
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Template path (--template)</label>
                    <div style="display: flex; gap: 8px;">
                        <input id="generatorTemplatePath" class="form-control" data-debug-id="FIELD_GENERATOR_TEMPLATE_PATH" value="/home/kimghw/Connector_auth/jinja/universal_server_template.jinja2" placeholder="/path/to/server_template.jinja2" style="flex: 1;">
                        <button class="btn btn-secondary" data-debug-id="BTN_GENERATOR_TEMPLATE_PICK" onclick="selectFilePath('generatorTemplatePath', '.jinja2')" style="padding: 8px 12px;">
                            <span class="material-icons" style="font-size: 18px;">folder_open</span>
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Output path (--output)</label>
                    <div style="display: flex; gap: 8px;">
                        <input id="generatorOutputPath" class="form-control" data-debug-id="FIELD_GENERATOR_OUTPUT_PATH" placeholder="/path/to/server_generated.py" style="flex: 1;">
                        <button class="btn btn-secondary" data-debug-id="BTN_GENERATOR_OUTPUT_PICK" onclick="selectFilePath('generatorOutputPath', '.py')" style="padding: 8px 12px;">
                            <span class="material-icons" style="font-size: 18px;">folder_open</span>
                        </button>
                    </div>
                </div>
                <div id="generatorResult" style="color: var(--text-secondary); font-size: 13px;"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-important" data-debug-id="BTN_GENERATOR_RUN" onclick="runServerGeneration()">
                    <span class="material-icons">auto_fix_high</span> Generate
                </button>
                <button class="btn btn-secondary" data-debug-id="BTN_GENERATOR_CLOSE_FOOTER" onclick="closeModal('generatorModal')">Close</button>
            </div>
        </div>
    </div>

    <script>
        let tools = [];
        let internalArgs = {};  // Internal args (hidden from MCP signature)
        let fileMtimes = {};    // File modification times for conflict detection
        let currentToolIndex = -1;
        let nestedGraphTarget = null;
        let currentProfile = '';
        let profiles = [];
        let generatorModules = [];
        let generatorFallback = {};
        let templateSources = [];  // Available template files (current, backups, other profiles)
        let originalProfile = '';  // The profile that tools were originally loaded from (for saving)
        let debugIndexEnabled = false;
        let debugIndexObserver = null;
        let debugIndexRefreshPending = false;
        let debugMetadataDirty = true;

        // Load tools on page load
        window.onload = function() {
            console.log('[DEBUG] window.onload triggered');
            console.log('[DEBUG] Calling loadProfiles()...');
            loadProfiles();  // This will call loadGraphTypesProperties() after profile is loaded
            initDebugIndexing();
            console.log('[DEBUG] Calling checkServerStatus()...');
            checkServerStatus();
            // Auto-refresh server status every 5 seconds
            setInterval(checkServerStatus, 5000);
            console.log('[DEBUG] window.onload completed');
        };

        function loadTemplateSources() {
            // Load available template files (current, backups, other profiles)
            const profileQuery = profileParam();
            fetch(`/api/template-sources${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    templateSources = data.sources || [];
                    renderTemplateSourceSelector();
                })
                .catch(error => {
                    console.error('Error loading template sources:', error);
                    templateSources = [];
                    renderTemplateSourceSelector();
                });
        }

        function renderTemplateSourceSelector() {
            const select = document.getElementById('templateSource');
            if (!select) return;

            select.innerHTML = '<option value="">-- Current Template --</option>';
            templateSources.forEach(source => {
                if (source.type === 'current') return; // Skip current, it's the default

                const opt = document.createElement('option');
                opt.value = source.path;
                // Format: "backup_20241217.py (5 tools)" or "outlook template (3 tools)"
                const dateStr = source.modified ? new Date(source.modified).toLocaleString() : '';
                let label = source.name;
                if (source.type === 'backup') {
                    label = `ðŸ“¦ ${source.name}`;
                } else if (source.type === 'other_profile') {
                    label = `ðŸ“ ${source.name}`;
                }
                opt.textContent = `${label} (${source.count} tools)`;
                opt.title = dateStr ? `Modified: ${dateStr}` : '';
                select.appendChild(opt);
            });

            // Update save target label
            const saveLabel = document.getElementById('saveTargetLabel');
            if (saveLabel) {
                saveLabel.textContent = originalProfile || 'default';
            }
        }

        function loadFromSelectedTemplate() {
            const select = document.getElementById('templateSource');
            const statusEl = document.getElementById('templateLoadStatus');
            const sourcePath = select ? select.value : '';

            if (!sourcePath) {
                // Load from current template (default behavior)
                loadTools();
                return;
            }

            if (statusEl) {
                statusEl.textContent = 'Loading...';
                statusEl.style.color = '#666';
            }

            fetch('/api/template-sources/load', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: sourcePath })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    tools = data.tools;
                    currentToolIndex = -1;
                    renderToolList();

                    if (statusEl) {
                        statusEl.textContent = `âœ“ Loaded ${data.count} tools`;
                        statusEl.style.color = '#34c759';
                        setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
                    }

                    showNotification(`Loaded ${data.count} tools from template. Save will update "${originalProfile || 'default'}"`, 'success');

                    // Clear editor
                    const editorContent = document.getElementById('editorContent');
                    if (editorContent) {
                        editorContent.innerHTML = `
                            <div style="text-align: center; padding: 50px; color: var(--text-secondary);">
                                <p>Loaded ${data.count} tools from: ${sourcePath.split('/').pop()}</p>
                                <p style="font-size: 12px; margin-top: 10px;">Select a tool from the left sidebar to edit</p>
                            </div>
                        `;
                    }
                } else {
                    if (statusEl) {
                        statusEl.textContent = 'âœ— Failed';
                        statusEl.style.color = '#ff3b30';
                    }
                    showNotification(`Error: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error loading template:', error);
                if (statusEl) {
                    statusEl.textContent = 'âœ— Failed';
                    statusEl.style.color = '#ff3b30';
                }
                showNotification('Failed to load template', 'error');
            });
        }

        // ===== MCP Server Control Functions =====
        function checkServerStatus() {
            const profileQuery = profileParam();
            fetch(`/api/server/status${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    updateServerStatusUI(data);
                })
                .catch(error => {
                    console.error('Error checking server status:', error);
                    updateServerStatusUI({ running: false, error: error.message });
                });
        }

        function updateServerStatusUI(status) {
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const btnStart = document.getElementById('btnStart');
            const btnStop = document.getElementById('btnStop');
            const btnRestart = document.getElementById('btnRestart');
            const pidInfo = document.getElementById('pidInfo');
            const pidValue = document.getElementById('pidValue');
            const profileValue = document.getElementById('profileValue');

            if (status.running) {
                // Server is running
                statusIndicator.style.background = '#28a745';
                statusText.textContent = 'Running';
                statusText.style.color = '#28a745';
                btnStart.disabled = true;
                btnStop.disabled = false;
                btnRestart.disabled = false;

                // Show PID info if available
                if (status.pid) {
                    pidInfo.style.display = 'block';
                    pidValue.textContent = status.pid;
                } else {
                    pidInfo.style.display = 'none';
                }
            } else {
                // Server is stopped
                statusIndicator.style.background = '#dc3545';
                statusText.textContent = 'Stopped';
                statusText.style.color = '#dc3545';
                btnStart.disabled = false;
                btnStop.disabled = true;
                btnRestart.disabled = true;
                pidInfo.style.display = 'none';
            }

            // Update profile info
            if (profileValue && status.profile) {
                profileValue.textContent = status.profile;
            }
        }

        function startServer() {
            const profileQuery = profileParam();
            const btnStart = document.getElementById('btnStart');
            const statusText = document.getElementById('statusText');

            btnStart.disabled = true;
            statusText.textContent = 'Starting...';
            statusText.style.color = '#ffc107';

            fetch(`/api/server/start${profileQuery}`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('Server started successfully', 'success');
                        checkServerStatus();
                    } else {
                        showToast('Failed to start server: ' + (data.error || 'Unknown error'), 'error');
                        btnStart.disabled = false;
                        statusText.textContent = 'Stopped';
                        statusText.style.color = '#dc3545';
                    }
                })
                .catch(error => {
                    showToast('Error starting server: ' + error.message, 'error');
                    btnStart.disabled = false;
                    statusText.textContent = 'Stopped';
                    statusText.style.color = '#dc3545';
                });
        }

        function stopServer() {
            const profileQuery = profileParam();
            const btnStop = document.getElementById('btnStop');
            const statusText = document.getElementById('statusText');

            btnStop.disabled = true;
            statusText.textContent = 'Stopping...';
            statusText.style.color = '#ffc107';

            fetch(`/api/server/stop${profileQuery}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ force: false })
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('Server stopped successfully', 'success');
                        checkServerStatus();
                    } else {
                        showToast('Failed to stop server: ' + (data.error || 'Unknown error'), 'error');
                        btnStop.disabled = false;
                        checkServerStatus();
                    }
                })
                .catch(error => {
                    showToast('Error stopping server: ' + error.message, 'error');
                    btnStop.disabled = false;
                    checkServerStatus();
                });
        }

        function restartServer() {
            const profileQuery = profileParam();
            const btnRestart = document.getElementById('btnRestart');
            const statusText = document.getElementById('statusText');

            btnRestart.disabled = true;
            statusText.textContent = 'Restarting...';
            statusText.style.color = '#ffc107';

            fetch(`/api/server/restart${profileQuery}`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showToast('Server restarted successfully', 'success');
                        checkServerStatus();
                    } else {
                        showToast('Failed to restart server: ' + (data.error || 'Unknown error'), 'error');
                        btnRestart.disabled = false;
                        checkServerStatus();
                    }
                })
                .catch(error => {
                    showToast('Error restarting server: ' + error.message, 'error');
                    btnRestart.disabled = false;
                    checkServerStatus();
                });
        }
        // ===== End of MCP Server Control Functions =====

        function loadMcpServices() {
            // Load MCP services for current profile
            const profileQuery = originalProfile ? `?profile=${encodeURIComponent(originalProfile)}` : '';

            fetch(`/api/mcp-services${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    window.mcpServiceDetails = data.services_with_signatures || [];
                    // Use service names from services_with_signatures (these match mcp_service.name)
                    // Fall back to data.services if services_with_signatures is empty
                    if (window.mcpServiceDetails.length > 0) {
                        window.mcpServices = window.mcpServiceDetails.map(svc => svc.name).filter(Boolean);
                    } else {
                        window.mcpServices = data.services || [];
                    }
                    console.log('MCP Services loaded:', window.mcpServices, 'from profile:', originalProfile || 'default');
                    console.log('MCP Service details loaded:', window.mcpServiceDetails);

                    if (currentToolIndex >= 0) {
                        renderToolEditor(tools[currentToolIndex], currentToolIndex);
                    }
                })
                .catch(error => {
                    console.error('Error loading MCP services:', error);
                    window.mcpServices = [];
                    window.mcpServiceDetails = [];
                });
        }

        function loadTools() {
            console.log('[DEBUG] loadTools() called');
            const profileQuery = profileParam();
            fetch(`/api/tools${profileQuery}`)
                .then(response => {
                    console.log('[DEBUG] Response received:', response.status, response.ok);
                    return response.json();
                })
                .then(data => {
                    console.log('[DEBUG] Data received:', data);
                    const loadedTools = data.tools || data;
                    tools = loadedTools;
                    // Load internal args and file mtimes from new API response format
                    internalArgs = data.internal_args || {};
                    fileMtimes = data.file_mtimes || {};
                    console.log('[DEBUG] tools variable set, tools.length:', tools.length);
                    console.log('[DEBUG] internalArgs loaded:', Object.keys(internalArgs).length, 'tools');
                    console.log('[DEBUG] Calling renderToolList()...');
                    renderToolList();
                    console.log('[DEBUG] renderToolList() completed');
                    showNotification(`Tools loaded (${currentProfile || 'default'})`, 'success');
                })
                .catch(error => {
                    console.error('[ERROR] Error loading tools:', error);
                    showNotification('Failed to load tools', 'error');
                });
        }

        // Load graph types properties for current profile
        function loadGraphTypesProperties() {
            const profileQuery = originalProfile ? `?profile=${encodeURIComponent(originalProfile)}` : '';
            return fetch(`/api/graph-types-properties${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    window.graphTypesProperties = data;
                    window.hasTypesFile = data.has_types || false;
                    window.typesName = data.types_name || 'types';
                    console.log('Loaded graph types properties:', data, 'hasTypes:', window.hasTypesFile, 'typesName:', window.typesName);
                    return data;
                })
                .catch(error => {
                    console.error('Error loading graph types properties:', error);
                    window.graphTypesProperties = null;
                    window.hasTypesFile = false;
                    window.typesName = 'types';
                    return null;
                });
        }

        function loadProfiles() {
            fetch('/api/profiles')
                .then(response => response.json())
                .then(data => {
                    profiles = data.profiles || [];
                    currentProfile = data.active || (profiles[0] || '');
                    originalProfile = currentProfile;  // Store original profile for saving
                    renderProfileTabs();
                    loadTools();
                    loadGeneratorDefaults();
                    loadTemplateSources();  // Load available template sources
                    loadMcpServices();  // Load MCP services for current profile
                    loadGraphTypesProperties();  // Load graph types for current profile
                })
                .catch(error => {
                    console.error('Error loading profiles:', error);
                    profiles = [];
                    currentProfile = '';
                    originalProfile = '';
                    renderProfileTabs();
                    loadTools();
                    loadGeneratorDefaults();
                    loadTemplateSources();
                    loadMcpServices();
                    loadGraphTypesProperties();
                });
        }

        function loadGeneratorDefaults() {
            const profileQuery = profileParam();
            fetch(`/api/server-generator/defaults${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    generatorModules = data.modules || [];
                    generatorFallback = data.fallback || {};
                    renderGeneratorOptions();
                })
                .catch(error => {
                    console.error('Error loading generator defaults:', error);
                    generatorModules = [];
                    generatorFallback = {};
                });
        }

        function renderGeneratorOptions() {
            const select = document.getElementById('generatorModule');
            if (!select) return;

            select.innerHTML = '<option value="">Custom / Current Profile</option>';
            generatorModules.forEach(mod => {
                const opt = document.createElement('option');
                opt.value = mod.name;
                opt.textContent = mod.name;
                select.appendChild(opt);
            });

            // Prefer module matching current profile, fallback to first module
            let defaultValue = '';
            if (currentProfile) {
                // Try to find a module matching the active profile name
                const matchingModule = generatorModules.find(mod =>
                    mod.name.toLowerCase() === currentProfile.toLowerCase() ||
                    mod.name.toLowerCase().includes(currentProfile.toLowerCase()) ||
                    currentProfile.toLowerCase().includes(mod.name.toLowerCase())
                );
                if (matchingModule) {
                    defaultValue = matchingModule.name;
                }
            }
            // Fallback to first module if no profile match
            if (!defaultValue && generatorModules.length > 0) {
                defaultValue = generatorModules[0].name;
            }

            select.value = defaultValue;
            applyGeneratorDefaults(defaultValue);
        }

        function applyGeneratorDefaults(moduleName) {
            const defaults = generatorModules.find(m => m.name === moduleName) || generatorFallback || {};
            const toolsInput = document.getElementById('generatorToolsPath');
            const templateInput = document.getElementById('generatorTemplatePath');
            const outputInput = document.getElementById('generatorOutputPath');

            if (toolsInput) toolsInput.value = defaults.tools_path || '';
            // Always use the universal template as default
            if (templateInput) templateInput.value = defaults.template_path || '/home/kimghw/Connector_auth/jinja/universal_server_template.jinja2';
            if (outputInput) outputInput.value = defaults.output_path || '';
        }

        function handleGeneratorModuleChange() {
            const select = document.getElementById('generatorModule');
            const moduleName = select ? select.value : '';
            applyGeneratorDefaults(moduleName);
        }

        // File selector function
        function selectFilePath(inputId, extension) {
            showFileBrowser(inputId, extension);
        }

        function showFileBrowser(inputId, extension) {
            // Remove existing modal if any
            const existing = document.getElementById('fileBrowserModal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'fileBrowserModal';
            modal.className = 'modal show';

            // Get initial path from the input field or use default
            const currentValue = document.getElementById(inputId)?.value || '';
            const initialPath = currentValue ?
                (currentValue.includes('/') ? currentValue.substring(0, currentValue.lastIndexOf('/')) : '/home/kimghw/Connector_auth') :
                getDefaultPath(inputId, '', extension).substring(0, getDefaultPath(inputId, '', extension).lastIndexOf('/'));

            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px;">
                    <div class="modal-header">
                        <h3>Select File</h3>
                        <button class="btn btn-icon" onclick="closeFileBrowser()">âœ•</button>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 12px;">
                            <input type="text" id="fileBrowserPath" class="form-control"
                                   placeholder="/home/kimghw/Connector_auth/..."
                                   value="${initialPath}"
                                   onkeypress="if(event.key==='Enter') browsePath('${inputId}', '${extension}')">
                            <div style="display: flex; gap: 8px; margin-top: 8px;">
                                <button class="btn btn-secondary" onclick="browsePath('${inputId}', '${extension}')">
                                    <span class="material-icons" style="font-size: 16px;">refresh</span> Browse
                                </button>
                                <button class="btn btn-secondary" id="parentDirBtn" onclick="browseParent('${inputId}', '${extension}')" style="display:none;">
                                    <span class="material-icons" style="font-size: 16px;">arrow_upward</span> Parent
                                </button>
                            </div>
                        </div>
                        <div id="fileBrowserContent" style="border: 1px solid var(--border-color);
                                                            border-radius: 4px; padding: 8px;
                                                            max-height: 400px; overflow-y: auto;
                                                            background: var(--bg-primary);">
                            <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                Click "Browse" to load directory contents
                            </div>
                        </div>
                        <div style="margin-top: 12px;">
                            <input type="text" id="selectedFilePath" class="form-control"
                                   placeholder="Selected file path will appear here" readonly>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-primary" onclick="applySelectedFile('${inputId}')" id="applyFileBtn" disabled>Apply</button>
                        <button class="btn btn-secondary" onclick="closeFileBrowser()">Cancel</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Auto-browse initial path
            browsePath(inputId, extension);
        }

        async function browsePath(inputId, extension) {
            const pathInput = document.getElementById('fileBrowserPath');
            const contentDiv = document.getElementById('fileBrowserContent');
            const parentBtn = document.getElementById('parentDirBtn');

            if (!pathInput || !contentDiv) return;

            const path = pathInput.value || '/home/kimghw/Connector_auth';

            contentDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Loading...</div>';

            try {
                const response = await fetch('/api/browse-files', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path, extension })
                });

                const data = await response.json();

                if (data.error) {
                    contentDiv.innerHTML = `<div style="color: red; padding: 20px;">${data.error}</div>`;
                    return;
                }

                // Update path input with actual path
                pathInput.value = data.current_path;

                // Show/hide parent button
                if (parentBtn) {
                    parentBtn.style.display = data.parent_path ? 'inline-flex' : 'none';
                    parentBtn.setAttribute('data-parent-path', data.parent_path || '');
                }

                // Build content HTML
                let html = '';

                // Add directories
                if (data.dirs && data.dirs.length > 0) {
                    html += '<div style="margin-bottom: 12px;"><strong>Directories:</strong></div>';
                    data.dirs.forEach(dir => {
                        html += `
                            <div style="padding: 4px 8px; cursor: pointer; display: flex; align-items: center; gap: 8px;"
                                 onmouseover="this.style.background='var(--hover-bg)'"
                                 onmouseout="this.style.background='transparent'"
                                 onclick="navigateToDir('${data.current_path}/${dir}', '${inputId}', '${extension}')">
                                <span class="material-icons" style="font-size: 16px; color: #ffc107;">folder</span>
                                <span>${dir}/</span>
                            </div>
                        `;
                    });
                }

                // Add files
                if (data.files && data.files.length > 0) {
                    if (html) html += '<hr style="margin: 12px 0; border-color: var(--border-color);">';
                    html += '<div style="margin-bottom: 12px;"><strong>Files:</strong></div>';
                    data.files.forEach(file => {
                        const filePath = `${data.current_path}/${file}`;
                        html += `
                            <div style="padding: 4px 8px; cursor: pointer; display: flex; align-items: center; gap: 8px;"
                                 onmouseover="this.style.background='var(--hover-bg)'"
                                 onmouseout="this.style.background='transparent'"
                                 onclick="selectFile('${filePath}', '${inputId}')">
                                <span class="material-icons" style="font-size: 16px; color: #2196f3;">insert_drive_file</span>
                                <span>${file}</span>
                            </div>
                        `;
                    });
                } else if (!data.dirs || data.dirs.length === 0) {
                    html = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No files or directories found</div>';
                }

                contentDiv.innerHTML = html;

            } catch (error) {
                console.error('Error browsing files:', error);
                contentDiv.innerHTML = '<div style="color: red; padding: 20px;">Error loading directory</div>';
            }
        }

        function navigateToDir(path, inputId, extension) {
            document.getElementById('fileBrowserPath').value = path;
            browsePath(inputId, extension);
        }

        function browseParent(inputId, extension) {
            const parentBtn = document.getElementById('parentDirBtn');
            const parentPath = parentBtn?.getAttribute('data-parent-path');
            if (parentPath) {
                document.getElementById('fileBrowserPath').value = parentPath;
                browsePath(inputId, extension);
            }
        }

        function selectFile(filePath, inputId) {
            const selectedInput = document.getElementById('selectedFilePath');
            const applyBtn = document.getElementById('applyFileBtn');

            if (selectedInput) {
                selectedInput.value = filePath;
            }
            if (applyBtn) {
                applyBtn.disabled = false;
            }
        }

        function applySelectedFile(inputId) {
            const selectedPath = document.getElementById('selectedFilePath')?.value;
            if (selectedPath) {
                document.getElementById(inputId).value = selectedPath;
            }
            closeFileBrowser();
        }

        function closeFileBrowser() {
            const modal = document.getElementById('fileBrowserModal');
            if (modal) modal.remove();
        }

        function getDefaultPath(inputId, fileName, extension) {
            // Provide smart defaults based on the input field
            const basePath = '/home/kimghw/Connector_auth';

            if (inputId === 'generatorToolsPath') {
                // Default for tool definitions
                const serverName = currentProfile || 'outlook';
                return `${basePath}/mcp_editor/mcp_${serverName}/tool_definition_templates.py`;
            } else if (inputId === 'generatorTemplatePath') {
                // Default for template - always use universal template
                return `${basePath}/jinja/universal_server_template.jinja2`;
            } else if (inputId === 'generatorOutputPath') {
                // Default for output
                const serverName = currentProfile || 'outlook';
                return `${basePath}/mcp_${serverName}/mcp_server/server.py`;
            }

            return `${basePath}/${fileName}`;
        }

        function openCreateProjectModal() {
            // Clear form
            document.getElementById('projectServiceName').value = '';
            document.getElementById('projectDescription').value = '';
            document.getElementById('projectPort').value = '8080';
            document.getElementById('projectAuthor').value = '';
            document.getElementById('projectIncludeTypes').checked = true;

            // Hide result
            const resultEl = document.getElementById('createProjectResult');
            resultEl.style.display = 'none';
            resultEl.textContent = '';

            document.getElementById('createProjectModal').classList.add('show');
        }

        function createNewProject() {
            const serviceName = document.getElementById('projectServiceName').value.trim();
            const description = document.getElementById('projectDescription').value.trim();
            const port = parseInt(document.getElementById('projectPort').value) || 8080;
            const author = document.getElementById('projectAuthor').value.trim();
            const includeTypes = document.getElementById('projectIncludeTypes').checked;

            if (!serviceName) {
                alert('Service name is required');
                return;
            }

            // Validate service name
            if (!/^[a-zA-Z0-9_]+$/.test(serviceName)) {
                alert('Service name can only contain letters, numbers, and underscores');
                return;
            }

            const resultEl = document.getElementById('createProjectResult');
            resultEl.style.display = 'block';
            resultEl.style.backgroundColor = '#e3f2fd';
            resultEl.textContent = 'Creating project...';

            fetch('/api/create-mcp-project', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    service_name: serviceName,
                    description: description,
                    port: port,
                    author: author,
                    include_types: includeTypes
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    resultEl.style.backgroundColor = '#e8f5e9';
                    resultEl.innerHTML = `
                        <strong>âœ… Success!</strong><br>
                        Created project: ${data.project_dir}<br>
                        Files created: ${data.created_files}<br><br>
                        <strong>Next steps:</strong><br>
                        1. Reload this page to see the new profile<br>
                        2. Select "${data.service_name}" from the profile tabs<br>
                        3. Start adding tools via the web editor
                    `;

                    // Reload profiles after 3 seconds
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                } else {
                    resultEl.style.backgroundColor = '#ffebee';
                    resultEl.textContent = 'âŒ Error: ' + (data.error || 'Unknown error occurred');
                }
            })
            .catch(error => {
                resultEl.style.backgroundColor = '#ffebee';
                resultEl.textContent = 'âŒ Error: ' + error.message;
            });
        }

        function openGeneratorModal() {
            if (!generatorModules.length && !generatorFallback.tools_path) {
                loadGeneratorDefaults();
            }
            applyGeneratorDefaults(document.getElementById('generatorModule')?.value || '');
            const resultEl = document.getElementById('generatorResult');
            if (resultEl) resultEl.textContent = '';
            document.getElementById('generatorModal').classList.add('show');
        }

        function runServerGeneration() {
            const profileQuery = profileParam();
            const payload = {
                module: document.getElementById('generatorModule')?.value || null,
                tools_path: document.getElementById('generatorToolsPath')?.value || '',
                template_path: document.getElementById('generatorTemplatePath')?.value || '',
                output_path: document.getElementById('generatorOutputPath')?.value || ''
            };

            fetch(`/api/server-generator${profileQuery}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({status: response.status, data})))
            .then(({status, data}) => {
                const resultEl = document.getElementById('generatorResult');
                if (status >= 200 && status < 300 && data.success) {
                    showNotification(`Generated server at ${data.output_path}`, 'success');
                    if (resultEl) resultEl.textContent = `Output: ${data.output_path} (${data.tool_count} tools)`;
                } else {
                    const message = data.error || 'Failed to generate server';
                    showNotification(message, 'error');
                    if (resultEl) resultEl.textContent = message;
                }
            })
            .catch(error => {
                console.error('Error generating server:', error);
                showNotification('Failed to generate server', 'error');
            });
        }

        function renderProfileTabs() {
            const tabContainer = document.getElementById('profileTabs');
            if (!tabContainer) return;
            tabContainer.innerHTML = '';
            if (!profiles || profiles.length === 0) {
                tabContainer.textContent = 'No profiles found (using default)';
            } else {
                profiles.filter(name => name && name.trim()).forEach((name, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn btn-secondary';
                    btn.setAttribute('data-debug-id', `PROFILE_${index + 1}`);
                    btn.style = 'border-radius: 8px; padding: 10px 20px; font-size: 15px; min-width: 120px; text-align: center; font-weight: bold;';
                    if (name === currentProfile) {
                        btn.style.background = 'var(--primary-color)';
                        btn.style.color = '#fff';
                    }
                    btn.textContent = name;
                    btn.onclick = () => {
                        currentProfile = name;
                        originalProfile = name;  // Update original profile when switching
                        renderProfileTabs();
                        loadTools();
                        loadGeneratorDefaults();
                        loadTemplateSources();  // Reload template sources for new profile
                        loadMcpServices();  // Reload MCP services for new profile
                        loadGraphTypesProperties();  // Reload types for new profile
                        // Reset template selector to default
                        const templateSelect = document.getElementById('templateSource');
                        if (templateSelect) templateSelect.value = '';
                    };
                    tabContainer.appendChild(btn);
                });
            }
        }

        function showNewProjectModal() {
            // Remove existing modal if any
            const existing = document.getElementById('newProjectModal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'newProjectModal';
            modal.style = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); display: flex; align-items: center;
                justify-content: center; z-index: 1000;
            `;
            modal.innerHTML = `
                <div style="background: var(--card-bg); padding: 24px; border-radius: 12px; width: 500px; max-width: 90%;">
                    <h3 style="margin-top: 0; margin-bottom: 16px;">New Project</h3>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label>Project Name *</label>
                        <input type="text" id="newProjectName" class="form-control" placeholder="e.g., calendar, teams, sharepoint">
                        <small style="color: var(--text-secondary);">Will be used as profile name (lowercase, underscores)</small>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label>MCP Server Path</label>
                        <input type="text" id="newProjectMcpPath" class="form-control" placeholder="../mcp_{name}/mcp_server">
                        <small style="color: var(--text-secondary);">Path to MCP server directory (relative to mcp_editor)</small>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label>Port</label>
                        <input type="number" id="newProjectPort" class="form-control" value="8091">
                    </div>
                    <div class="form-group" style="margin-bottom: 16px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="newProjectCreateMcp" checked>
                            Create MCP server directory structure
                        </label>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button class="btn btn-secondary" onclick="closeNewProjectModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="createNewProject()">Create Project</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.onclick = (e) => { if (e.target === modal) closeNewProjectModal(); };
            document.getElementById('newProjectName').focus();
        }

        function closeNewProjectModal() {
            const modal = document.getElementById('newProjectModal');
            if (modal) modal.remove();
        }

        async function createNewProject() {
            const name = document.getElementById('newProjectName').value.trim();
            if (!name) {
                showNotification('Project name is required', 'error');
                return;
            }

            const mcpPath = document.getElementById('newProjectMcpPath').value.trim() || `../mcp_${name.toLowerCase().replace(/\s+/g, '_')}/mcp_server`;
            const port = parseInt(document.getElementById('newProjectPort').value) || 8091;
            const createMcp = document.getElementById('newProjectCreateMcp').checked;

            try {
                const response = await fetch('/api/profiles', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        mcp_server_path: mcpPath,
                        port: port,
                        create_mcp_structure: createMcp
                    })
                });

                const result = await response.json();
                if (result.error) {
                    showNotification(result.error, 'error');
                    return;
                }

                showNotification(`Project "${result.profile}" created successfully!`, 'success');
                closeNewProjectModal();

                // Reload profiles and switch to new one
                profiles.push(result.profile);
                currentProfile = result.profile;
                renderProfileTabs();
                loadTools();
                loadGeneratorDefaults();
            } catch (error) {
                showNotification('Failed to create project: ' + error.message, 'error');
            }
        }

        function profileParam() {
            // Always use originalProfile for saving operations
            // This ensures changes are saved to the profile where tools were loaded from,
            // even if MCP services are loaded from a different template source
            return originalProfile ? `?profile=${encodeURIComponent(originalProfile)}` : '';
        }

        function populateGraphTypeOptions(selectEl) {
            if (!selectEl || !window.graphTypesProperties || !Array.isArray(window.graphTypesProperties.classes)) {
                return;
            }
            const existing = Array.from(selectEl.options).map(opt => opt.value);
            window.graphTypesProperties.classes.forEach(cls => {
                const name = cls.name || '';
                if (!name || existing.includes(name)) {
                    return;
                }
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectEl.appendChild(option);
            });
        }

        function renderToolList() {
            console.log('[DEBUG] renderToolList() called');
            console.log('[DEBUG] tools.length:', tools.length);
            console.log('[DEBUG] currentToolIndex:', currentToolIndex);

            const toolList = document.getElementById('toolList');
            if (!toolList) {
                console.error('[ERROR] toolList element not found!');
                return;
            }
            console.log('[DEBUG] toolList element found');

            console.log('[DEBUG] Clearing toolList.innerHTML');
            toolList.innerHTML = '';

            console.log('[DEBUG] Starting forEach loop...');
            tools.forEach((tool, index) => {
                console.log(`[DEBUG] Processing tool ${index}: ${tool.name}`);
                const toolItem = document.createElement('div');
                toolItem.className = 'tool-item';
                toolItem.setAttribute('data-debug-id', `TOOL_${index}`);
                if (index === currentToolIndex) {
                    toolItem.classList.add('active');
                }
                toolItem.onclick = () => selectTool(index);

                // Get service method info
                const serviceName = typeof tool.mcp_service === 'string'
                    ? tool.mcp_service
                    : tool.mcp_service?.name;
                const serviceMethodHtml = serviceName
                    ? `<div style="margin-top: 5px; font-size: 11px; color: var(--primary-color); font-weight: 500;">
                        <span style="color: #666;">Service:</span> ${serviceName}
                       </div>`
                    : '';

                toolItem.innerHTML = `
                    <h3>${tool.name}</h3>
                    <p>${tool.description}</p>
                    ${serviceMethodHtml}
                `;
                toolList.appendChild(toolItem);
                console.log(`[DEBUG] Tool ${index} appended to DOM`);
            });
            console.log('[DEBUG] forEach loop completed, total tools:', tools.length);
        }

        function selectTool(index) {
            currentToolIndex = index;
            renderToolList();
            renderToolEditor(tools[index], index);
        }

        function renderToolEditor(tool, index) {
            const editorContent = document.getElementById('editorContent');

            const properties = tool.inputSchema?.properties || {};
            const required = tool.inputSchema?.required || [];

            // Helper to check if property is internal
            const getToolInternalArgs = () => internalArgs[tool.name] || {};
            const isPropertyInternal = (propName) => {
                const toolInternalArgs = getToolInternalArgs();
                return propName in toolInternalArgs;
            };

            // Check if property is MCP service parameter
            const normalizeMcpPropName = (propName) => {
                if (propName && propName.endsWith('_internal')) {
                    return propName.slice(0, -'_internal'.length);
                }
                return propName;
            };

            const isPropertyMcpParam = (propName) => {
                if (!tool.mcp_service) {
                    return false;
                }

                const serviceName = typeof tool.mcp_service === 'object'
                    ? tool.mcp_service?.name
                    : tool.mcp_service;
                if (!serviceName) {
                    return false;
                }

                const serviceDetail = window.mcpServiceDetails
                    ? window.mcpServiceDetails.find(svc => svc.name === serviceName)
                    : null;
                const parameters = (serviceDetail && Array.isArray(serviceDetail.parameters))
                    ? serviceDetail.parameters
                    : (typeof tool.mcp_service === 'object' ? tool.mcp_service.parameters : null);
                if (!Array.isArray(parameters)) {
                    return false;
                }

                const normalizedName = normalizeMcpPropName(propName);
                return parameters.some(param => {
                    if (!param) {
                        return false;
                    }
                    if (typeof param === 'string') {
                        return param === normalizedName;
                    }
                    return param.name === normalizedName;
                });
            };

            // CRITICAL: Merge properties from inputSchema AND internalArgs
            // This ensures internal-only properties remain visible and editable
            const toolInternalArgs = getToolInternalArgs();
            const allPropertyNames = new Set([
                ...Object.keys(properties),
                ...Object.keys(toolInternalArgs)
            ]);

            let propertiesHtml = '';
            for (const propName of allPropertyNames) {
                // Get propDef from inputSchema if it exists, otherwise reconstruct from internalArgs
                const isInternal = isPropertyInternal(propName);
                let propDef;
                if (properties[propName]) {
                    propDef = properties[propName];
                } else if (isInternal && toolInternalArgs[propName].original_schema) {
                    // Use stored original_schema for display (but don't modify inputSchema)
                    propDef = toolInternalArgs[propName].original_schema;
                } else if (isInternal) {
                    // Fallback: create minimal schema from internal arg info
                    propDef = {
                        type: toolInternalArgs[propName].type || 'object',
                        description: toolInternalArgs[propName].description || ''
                    };
                } else {
                    continue; // Skip if neither in properties nor internal
                }
                // Original loop logic below uses propName and propDef
                const isRequired = required.includes(propName);
                // isInternal already set above
                const isMcpParam = isPropertyMcpParam(propName);
                const propId = `prop-${index}-${propName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                propertiesHtml += `
                    <div class="property-collapsible" data-internal="${isInternal}">
                        <div class="property-collapse-header" onclick="togglePropertyCollapse('${propId}')" id="header-${propId}"
                             style="${isInternal ? 'border-left: 3px solid var(--warning-color);' : ''}">
                            <div style="display: flex; align-items: center;">
                                <span class="collapse-icon" id="icon-${propId}">â–¼</span>
                                <input type="text" value="${propName}"
                                       id="propname-${propId}"
                                       data-original-name="${propName}"
                                       style="font-size: 15px; color: #333; font-weight: bold; border: 1px solid transparent; background: transparent; padding: 2px 6px; border-radius: 4px; min-width: 100px;"
                                       onfocus="this.style.borderColor='var(--primary-color)'; this.style.background='white';"
                                       onblur="renameSchemaProperty(${index}, this.dataset.originalName, this.value, this); this.style.borderColor='transparent'; this.style.background='transparent';"
                                       onkeypress="if(event.key === 'Enter') { this.blur(); }"
                                       onclick="event.stopPropagation();">
                                <span style="margin-left: 12px; font-size: 12px; color: #666; background: #f0f0f0; padding: 2px 8px; border-radius: 4px;">${propDef.type}</span>
                                ${propDef.targetParam ? `<span style="margin-left: 8px; font-size: 11px; color: #007bff; background: #e7f1ff; padding: 2px 6px; border-radius: 4px;" title="Maps to service method parameter">â†’ ${propDef.targetParam}</span>` : ''}
                                ${isRequired ? '<span style="margin-left: 8px; font-size: 11px; color: var(--danger-color); font-weight: 600;">REQUIRED</span>' : ''}
                                ${isInternal ? '<span style="margin-left: 8px; font-size: 10px; color: white; background: var(--warning-color); padding: 2px 6px; border-radius: 4px; font-weight: 600;">INTERNAL</span>' : ''}
                                ${isMcpParam ? `<span style="margin-left: 8px; font-size: 10px; color: white; background: ${isInternal ? 'var(--warning-color)' : 'var(--primary-color)'}; padding: 2px 6px; border-radius: 4px; font-weight: 600;">MCP</span>` : ''}
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px;" onclick="event.stopPropagation();">
                                ${propDef.type === 'object' ? `
                                <button class="btn btn-sm"
                                        style="background: ${propDef.baseModel ? 'var(--success-color)' : 'var(--primary-color)'}; color: white; padding: 4px 12px; border-radius: 980px; font-size: 11px;"
                                        onclick="showBaseModelSelector(${index}, '${propName}')">
                                    ${propDef.baseModel || 'Select BaseModel'}
                                </button>
                                ` : ''}
                                <label style="display: flex; align-items: center; cursor: pointer; margin: 0;">
                                    <input type="checkbox" ${isRequired ? 'checked' : ''}
                                           onchange="toggleRequired(${index}, '${propName}', this.checked)"
                                           style="margin-right: 6px;">
                                    <span style="color: ${isRequired ? 'var(--danger-color)' : 'var(--text-secondary)'}; font-size: 13px; font-weight: 500;">Required</span>
                                </label>
                                <button class="btn btn-icon btn-sm" onclick="removeProperty(${index}, '${propName}')"><span class="material-icons">close</span></button>
                            </div>
                        </div>
                        <div class="property-collapse-content" id="content-${propId}">
                        <div style="display: flex; gap: 10px; margin-bottom: 8px; align-items: center; flex-wrap: wrap;">
                            <span style="font-size: 11px; color: var(--text-secondary);">Dest:</span>
                            <label style="display: flex; align-items: center; cursor: pointer; padding: 4px 10px; border: 2px solid ${!isInternal ? 'var(--primary-color)' : 'var(--border-color)'}; border-radius: 5px; background: ${!isInternal ? 'rgba(0, 113, 227, 0.1)' : 'white'};">
                                <input type="radio" name="dest-${propId}" value="signature" ${!isInternal ? 'checked' : ''}
                                       onchange="setPropertyDestination(${index}, '${propName}', 'signature')" style="margin-right: 4px;">
                                <span style="font-size: 11px; font-weight: 500;">Signature</span>
                            </label>
                            <label style="display: flex; align-items: center; cursor: pointer; padding: 4px 10px; border: 2px solid ${isInternal ? 'var(--warning-color)' : 'var(--border-color)'}; border-radius: 5px; background: ${isInternal ? 'rgba(255, 159, 10, 0.1)' : 'white'};">
                                <input type="radio" name="dest-${propId}" value="internal" ${isInternal ? 'checked' : ''}
                                       onchange="setPropertyDestination(${index}, '${propName}', 'internal')" style="margin-right: 4px;">
                                <span style="font-size: 11px; font-weight: 500;">Internal</span>
                            </label>
                            <span style="font-size: 11px; color: var(--text-secondary); margin-left: 8px;">Type:</span>
                            <select class="form-control" style="width: auto; padding: 4px 8px; font-size: 11px;"
                                    onchange="updatePropertyField(${index}, '${propName}', 'type', this.value); renderToolEditor(tools[${index}], ${index});">
                                <option value="string" ${propDef.type === 'string' ? 'selected' : ''}>string</option>
                                <option value="number" ${propDef.type === 'number' ? 'selected' : ''}>number</option>
                                <option value="integer" ${propDef.type === 'integer' ? 'selected' : ''}>integer</option>
                                <option value="boolean" ${propDef.type === 'boolean' ? 'selected' : ''}>boolean</option>
                                <option value="array" ${propDef.type === 'array' ? 'selected' : ''}>array</option>
                                <option value="object" ${propDef.type === 'object' ? 'selected' : ''}>object</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label style="font-size: 11px;">Service Method Parameter</label>
                            <select class="form-control" style="font-size: 12px;"
                                    id="targetparam-${propId}"
                                    onchange="updatePropertyField(${index}, '${propName}', 'targetParam', this.value || undefined)">
                                <option value="">-- Same as Input Schema Name (${propName}) --</option>
                            </select>
                            <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                Maps this property to a specific service method parameter. Leave default if names match.
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label style="font-size: 11px;">Description</label>
                            <input class="form-control" style="font-size: 12px;"
                                   value="${(propDef.description || '').replace(/"/g, '&quot;')}"
                                   onchange="updatePropertyField(${index}, '${propName}', 'description', this.value)">
                        </div>
                        <div class="form-group" id="default-value-group-${propId}">
                            <label style="font-size: 11px;">Default Value ${propDef.type === 'array' || propDef.type === 'object' ? '(JSON)' : ''}</label>
                            ${propDef.type === 'array' || propDef.type === 'object' ? `
                            <textarea class="form-control" style="font-family: monospace; font-size: 12px; min-height: 120px; padding: 6px 8px;"
                                      placeholder='${propDef.type === 'array' ? '["item1", "item2"]' : '{"key": "value"}'}'
                                      onchange="updatePropertyField(${index}, '${propName}', 'default', parseDefaultValue(this.value, '${propDef.type}'))">${propDef.default !== undefined ? (typeof propDef.default === 'string' ? propDef.default : JSON.stringify(propDef.default, null, 2)) : ''}</textarea>
                            ` : `
                            <input class="form-control" style="font-size: 12px; padding: 6px 8px; height: 30px;"
                                   value="${propDef.default !== undefined ? propDef.default : ''}"
                                   placeholder="Optional default value"
                                   onchange="updatePropertyField(${index}, '${propName}', 'default', parseDefaultValue(this.value, '${propDef.type}'))">
                            `}
                        </div>
                        ${propDef.enum ? `
                        <div class="form-group">
                            <label>Enum Values (comma-separated)</label>
                            <input class="form-control" value="${propDef.enum.join(', ')}"
                                   onchange="updatePropertyEnum(${index}, '${propName}', this.value)">
                        </div>
                        ` : ''}
                        ${propDef.type === 'array' ? `
                        <div class="form-group">
                            <label>Array Item Type</label>
                            <select class="form-control"
                                    onchange="updatePropertyField(${index}, '${propName}', 'items', {type: this.value})">
                                <option value="string" ${propDef.items?.type === 'string' ? 'selected' : ''}>string</option>
                                <option value="number" ${propDef.items?.type === 'number' ? 'selected' : ''}>number</option>
                                <option value="integer" ${propDef.items?.type === 'integer' ? 'selected' : ''}>integer</option>
                                <option value="boolean" ${propDef.items?.type === 'boolean' ? 'selected' : ''}>boolean</option>
                                <option value="object" ${propDef.items?.type === 'object' ? 'selected' : ''}>object</option>
                            </select>
                        </div>
                        ` : ''}
                        ${propDef.type === 'object' && propDef.properties ? `
                        <div class="form-group">
                            <label style="display: flex; justify-content: space-between; align-items: center;">
                                <span>Nested Properties</span>
                                <div style="display: flex; gap: 6px; align-items: center;">
                                    <label style="font-size: 10px; color: var(--text-secondary); display: flex; align-items: center; margin: 0; cursor: pointer;">
                                        <input type="checkbox" id="nested-select-all-${index}-${propName.replace(/[^a-zA-Z0-9]/g, '_')}"
                                               onchange="toggleAllNestedCheckboxes(${index}, '${propName}', this.checked)"
                                               style="margin-right: 3px; transform: scale(0.9);">
                                        All
                                    </label>
                                    <button class="btn btn-icon btn-sm" style="padding: 4px; color: var(--danger-color); background: rgba(255, 59, 48, 0.1); border-radius: 4px; transition: all 0.2s;"
                                            onmouseover="this.style.background='rgba(255, 59, 48, 0.2)'"
                                            onmouseout="this.style.background='rgba(255, 59, 48, 0.1)'"
                                            onclick="removeSelectedNestedProperties(${index}, '${propName}')"
                                            title="Delete selected properties">
                                        <span class="material-icons" style="font-size: 16px;">delete</span>
                                    </button>
                                </div>
                            </label>
                            <div style="padding: 12px; background: var(--bg-color); border-left: 3px solid ${propDef.baseModel ? 'var(--success-color)' : 'var(--primary-color)'}; border-radius: var(--radius-sm);">
                                ${Object.entries(propDef.properties).map(([nestedPropName, nestedProp]) => {
                                    const nestedIsRequired = propDef.required && propDef.required.includes(nestedPropName);
                                    const nestedPropId = `nested-${index}-${propName}-${nestedPropName}`.replace(/[^a-zA-Z0-9-]/g, '_');
                                    return `
                                    <div class="nested-prop-collapsible" style="margin-bottom: 6px; background: white; border: 1px solid var(--border-color); border-radius: 6px; overflow: hidden;">
                                        <div class="nested-prop-header" onclick="toggleNestedPropCollapse('${nestedPropId}')"
                                             style="display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; cursor: pointer; background: #fafafa;">
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input type="checkbox" class="nested-prop-checkbox"
                                                       data-tool-index="${index}" data-parent-prop="${propName}" data-nested-prop="${nestedPropName}"
                                                       onclick="event.stopPropagation(); updateNestedSelectAllState(${index}, '${propName}')"
                                                       style="margin: 0;">
                                                <span class="nested-collapse-icon" id="nested-icon-${nestedPropId}" style="font-size: 10px; color: var(--text-secondary);">â–¶</span>
                                                <strong style="color: var(--text-primary); font-size: 12px;">${nestedPropName}</strong>
                                                <span style="font-size: 10px; color: #888; background: #eee; padding: 1px 6px; border-radius: 3px;">${nestedProp.type}</span>
                                                ${nestedIsRequired ? '<span style="font-size: 9px; color: var(--danger-color); font-weight: 600;">REQ</span>' : ''}
                                            </div>
                                            <div style="display: flex; gap: 6px; align-items: center;" onclick="event.stopPropagation();">
                                                <select style="font-size: 10px; padding: 2px 4px; border: 1px solid var(--border-color); border-radius: 4px; background: white;"
                                                        onchange="updateNestedPropertyType(${index}, '${propName}', '${nestedPropName}', this.value); renderToolEditor(tools[${index}], ${index});">
                                                    <option value="string" ${nestedProp.type === 'string' ? 'selected' : ''}>string</option>
                                                    <option value="number" ${nestedProp.type === 'number' ? 'selected' : ''}>number</option>
                                                    <option value="integer" ${nestedProp.type === 'integer' ? 'selected' : ''}>integer</option>
                                                    <option value="boolean" ${nestedProp.type === 'boolean' ? 'selected' : ''}>boolean</option>
                                                    <option value="array" ${nestedProp.type === 'array' ? 'selected' : ''}>array</option>
                                                    <option value="object" ${nestedProp.type === 'object' ? 'selected' : ''}>object</option>
                                                </select>
                                                <label style="display: flex; align-items: center; margin: 0; cursor: pointer;">
                                                    <input type="checkbox" ${nestedIsRequired ? 'checked' : ''}
                                                           onchange="toggleNestedRequired(${index}, '${propName}', '${nestedPropName}', this.checked)"
                                                           style="margin-right: 2px; transform: scale(0.8);">
                                                    <span style="color: ${nestedIsRequired ? 'var(--danger-color)' : 'var(--text-secondary)'}; font-size: 10px;">Req</span>
                                                </label>
                                                <button class="btn btn-icon btn-sm" style="padding: 4px; color: var(--text-secondary); border-radius: 4px; transition: all 0.2s;"
                                                        onmouseover="this.style.background='rgba(0,0,0,0.05)'; this.style.color='var(--danger-color)'"
                                                        onmouseout="this.style.background='transparent'; this.style.color='var(--text-secondary)'"
                                                        onclick="removeNestedPropertyInline(${index}, '${propName}', '${nestedPropName}')"><span class="material-icons" style="font-size: 16px;">delete_outline</span></button>
                                            </div>
                                        </div>
                                        <div class="nested-prop-content collapsed" id="nested-content-${nestedPropId}" style="padding: 10px; display: none;">
                                            <input class="form-control" style="font-size: 11px; margin-bottom: 6px; padding: 5px;"
                                                   placeholder="Description"
                                                   value="${(nestedProp.description || '').replace(/"/g, '&quot;')}"
                                                   onchange="updateNestedPropertyDescription(${index}, '${propName}', '${nestedPropName}', this.value)">
                                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                                                <div>
                                                    <label style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase;">Default</label>
                                                    <input class="form-control" style="font-size: 11px; padding: 5px;"
                                                           placeholder="default value"
                                                           value="${nestedProp.default !== undefined ? nestedProp.default : ''}"
                                                           onchange="updateNestedPropertyDefault(${index}, '${propName}', '${nestedPropName}', parseDefaultValue(this.value, '${nestedProp.type}'))">
                                                </div>
                                                ${(nestedProp.type === 'string' || nestedProp.type === 'number' || nestedProp.type === 'integer') ? `
                                                <div>
                                                    <label style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase;">Format</label>
                                                    <input class="form-control" style="font-size: 11px; padding: 5px;"
                                                           placeholder="date, email, uri"
                                                           value="${nestedProp.format || ''}"
                                                           onchange="updateNestedPropertyFormat(${index}, '${propName}', '${nestedPropName}', this.value)">
                                                </div>
                                                ` : '<div></div>'}
                                            </div>
                                            ${nestedProp.type === 'string' ? `
                                            <div style="margin-top: 6px;">
                                                <label style="font-size: 9px; color: var(--text-secondary); display: flex; align-items: center; text-transform: uppercase;">
                                                    <input type="checkbox" ${nestedProp.enum ? 'checked' : ''}
                                                           onchange="toggleNestedEnum(${index}, '${propName}', '${nestedPropName}', this.checked)"
                                                           style="margin-right: 4px; transform: scale(0.8);">
                                                    Has Enum
                                                </label>
                                                ${nestedProp.enum ? `
                                                <input class="form-control" style="font-size: 11px; padding: 5px; margin-top: 4px;"
                                                       placeholder="Comma-separated values"
                                                       value="${nestedProp.enum.join(', ')}"
                                                       onchange="updateNestedPropertyEnum(${index}, '${propName}', '${nestedPropName}', this.value)">
                                                ` : ''}
                                            </div>
                                            ` : ''}
                                            ${nestedProp.type === 'array' ? `
                                            <div style="margin-top: 6px;">
                                                <label style="font-size: 9px; color: var(--text-secondary); text-transform: uppercase;">Array Item Type</label>
                                                <select class="form-control" style="font-size: 11px; padding: 5px;"
                                                        onchange="updateNestedPropertyItems(${index}, '${propName}', '${nestedPropName}', this.value)">
                                                    <option value="string" ${nestedProp.items?.type === 'string' ? 'selected' : ''}>string</option>
                                                    <option value="number" ${nestedProp.items?.type === 'number' ? 'selected' : ''}>number</option>
                                                    <option value="integer" ${nestedProp.items?.type === 'integer' ? 'selected' : ''}>integer</option>
                                                    <option value="boolean" ${nestedProp.items?.type === 'boolean' ? 'selected' : ''}>boolean</option>
                                                    <option value="object" ${nestedProp.items?.type === 'object' ? 'selected' : ''}>object</option>
                                                </select>
                                            </div>
                                            ` : ''}
                                        </div>
                                    </div>
                                    `;
                                }).join('')}
                                ${window.hasTypesFile ? `
                                <button class="btn btn-secondary btn-sm" style="margin-top: 8px; font-size: 11px; padding: 4px 10px;"
                                        onclick="openNestedGraphTypesModal(${index}, '${propName}')">
                                    <span class="material-icons" style="font-size: 14px;">add</span> Add from ${window.typesName || 'types'}
                                </button>` : ''}
                            </div>
                        </div>
                        ` : propDef.type === 'object' ? `
                        <div class="form-group">
                            <label>Nested Properties</label>
                            <div style=" padding: 20px; background: var(--bg-color); border-radius: var(--radius-sm);">
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">No nested properties defined</div>
                                ${window.hasTypesFile ? `
                                <button class="btn btn-secondary btn-sm"
                                        onclick="openNestedGraphTypesModal(${index}, '${propName}')">
                                    <span class="material-icons">add</span> Add from ${window.typesName || 'types'}
                                </button>` : ''}
                            </div>
                        </div>
                        ` : ''}
                        ${propDef.type === 'string' ? `
                        <div class="form-group">
                            <label style="display: flex; align-items: center;">
                                <input type="checkbox" ${propDef.enum ? 'checked' : ''}
                                       onchange="toggleEnum(${index}, '${propName}', this.checked)"
                                       style="margin-right: 8px;">
                                Has Enum Values
                            </label>
                            ${propDef.enum ? `
                            <input class="form-control" value="${propDef.enum.join(', ')}"
                                   placeholder="Enter comma-separated values"
                                   onchange="updatePropertyEnum(${index}, '${propName}', this.value)">
                            ` : ''}
                        </div>
                        ` : ''}
                        </div>
                    </div>
                `;
            }

            editorContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-size: 20px; font-weight: 600;">Edit Tool: ${tool.name}</h2>
                    <button class="btn btn-danger btn-sm" data-debug-id="BTN_TOOL_DELETE" onclick="deleteTool(${index})">Delete Tool</button>
                </div>

                <div style="display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap; margin-bottom: 8px;">
                    <div class="form-group" style="flex: 1; min-width: 240px; margin-bottom: 0;">
                        <label>Tool Name</label>
                        <input class="form-control" id="toolName" data-debug-id="FIELD_TOOL_NAME" value="${tool.name}"
                               onchange="updateToolField(${index}, 'name', this.value)">
                    </div>
                    <div class="form-group" style="flex: 1; min-width: 260px; margin-bottom: 0;">
                        <label>MCP Service Method</label>
                        <select class="form-control" id="mcpService" data-debug-id="FIELD_TOOL_SERVICE"
                                onchange="updateMcpService(${index}, this.value)">
                            <option value="">-- Select MCP Service Method --</option>
                            ${window.mcpServices ? window.mcpServices.map(service => {
                                const currentService = typeof tool.mcp_service === 'object' ? tool.mcp_service?.name : tool.mcp_service;
                                return `<option value="${service}" ${currentService === service ? 'selected' : ''}>${service}</option>`;
                            }).join('') : ''}
                        </select>
                    </div>
                </div>

                ${(() => {
                    const serviceName = typeof tool.mcp_service === 'string'
                        ? tool.mcp_service
                        : tool.mcp_service?.name;

                    if (serviceName) {
                        return `
                        <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
                            <div style="font-size: 12px; font-weight: 600; color: #495057; margin-bottom: 8px;">
                                Service Method Parameters:
                            </div>
                            <div id="serviceMethodParams" style="font-size: 11px; color: #6c757d;">
                                Loading parameters...
                            </div>
                        </div>`;
                    }
                    return '';
                })()}

                <div class="form-group">
                    <label>Description</label>
                    <textarea class="form-control" id="toolDescription" data-debug-id="FIELD_TOOL_DESCRIPTION"
                              style="height: 60px; padding: 6px 8px; resize: vertical;"
                              onchange="updateToolField(${index}, 'description', this.value)">${tool.description}</textarea>
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <label style="margin: 0;">Input Schema Properties</label>
                        <div>
                            <button class="btn btn-sm btn-secondary" data-debug-id="BTN_PROP_EXPAND_ALL" onclick="expandAllProperties()" style="margin-right: 8px;">
                                â–¼ Expand All
                            </button>
                            <button class="btn btn-sm btn-secondary" data-debug-id="BTN_PROP_COLLAPSE_ALL" onclick="collapseAllProperties()">
                                â–¶ Collapse All
                            </button>
                        </div>
                    </div>
                    <div class="properties-container">
                        ${propertiesHtml}
                        <button class="add-button" data-debug-id="BTN_PROP_ADD" onclick="addProperty(${index})">
                            <span class="material-icons">add</span> Add Property
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <div class="collapsible-header" onclick="toggleJsonView()" style="background: #f0f0f0; padding: 10px; border-radius: 6px; cursor: pointer;">
                        <span class="collapse-icon" id="json-collapse-icon" style="display: inline-block; margin-right: 8px;">â–¼</span>
                        <label style="margin: 0; cursor: pointer; font-weight: 600;">Raw JSON View</label>
                    </div>
                    <div class="json-viewer" id="json-viewer" style="margin-top: 10px;">
                        <pre>${JSON.stringify(tool, null, 2)}</pre>
                    </div>
                </div>
            `;

            // Load and display service method parameters
            loadAndDisplayServiceMethodParams(index);

            // Load service method parameters for each existing property's targetParam dropdown
            loadTargetParamsForExistingProperties(index);
        }

        function loadTargetParamsForExistingProperties(index) {
            const tool = tools[index];
            const serviceName = typeof tool.mcp_service === 'string'
                ? tool.mcp_service
                : tool.mcp_service?.name;

            if (!serviceName) return;

            const currentProfile = window.currentProfile || 'mcp_outlook';
            fetch(`/api/registry?profile=${currentProfile}`)
                .then(response => response.json())
                .then(registry => {
                    if (registry && registry.services && registry.services[serviceName]) {
                        const service = registry.services[serviceName];
                        if (service.parameters) {
                            // Combine both inputSchema properties and internal args
                            const allProperties = {};

                            // Add inputSchema properties
                            if (tool.inputSchema?.properties) {
                                Object.entries(tool.inputSchema.properties).forEach(([propName, propDef]) => {
                                    allProperties[propName] = propDef;
                                });
                            }

                            // Add internal args
                            const toolInternalArgs = internalArgs[tool.name] || {};
                            Object.entries(toolInternalArgs).forEach(([propName, propDef]) => {
                                allProperties[propName] = propDef;
                            });

                            // Update each property's targetParam dropdown
                            Object.entries(allProperties).forEach(([propName, propDef]) => {
                                const propId = `prop-${index}-${propName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                                const select = document.getElementById(`targetparam-${propId}`);

                                if (select) {
                                    // Clear existing options except the first one
                                    select.innerHTML = `<option value="">-- Same as Input Schema Name (${propName}) --</option>`;

                                    // Add service method parameters as options
                                    service.parameters.forEach(param => {
                                        const option = document.createElement('option');
                                        option.value = param.name;
                                        option.textContent = `${param.name} (${param.type})`;
                                        if (propDef.targetParam === param.name) {
                                            option.selected = true;
                                        }
                                        select.appendChild(option);
                                    });
                                }
                            });
                        }
                    }
                })
                .catch(error => {
                    console.error('Failed to load target params for existing properties:', error);
                });
        }

        function loadAndDisplayServiceMethodParams(index) {
            const tool = tools[index];
            const serviceName = typeof tool.mcp_service === 'string'
                ? tool.mcp_service
                : tool.mcp_service?.name;

            const paramsDiv = document.getElementById('serviceMethodParams');
            if (!paramsDiv || !serviceName) return;

            // Load registry to get method parameters
            fetch('/api/registry')
                .then(response => response.json())
                .then(registry => {
                    if (registry && registry.services && registry.services[serviceName]) {
                        const service = registry.services[serviceName];

                        let paramsHtml = '';

                        // Show handler information
                        if (service.handler) {
                            paramsHtml += `
                                <div style="margin-bottom: 8px;">
                                    <strong>Class:</strong> ${service.handler.class_name || 'N/A'}<br>
                                    <strong>Method:</strong> ${service.handler.method || serviceName}<br>
                                    <strong>Module:</strong> ${service.handler.module_path || 'N/A'}
                                </div>
                            `;
                        }

                        // Show parameters and check coverage
                        if (service.parameters && service.parameters.length > 0) {
                            const schemaProperties = tool.inputSchema?.properties || {};
                            const toolInternalArgs = internalArgs[tool.name] || {};

                            // Get all properties from both schema and internal args
                            const allDefinedProps = new Set([
                                ...Object.keys(schemaProperties),
                                ...Object.keys(toolInternalArgs)
                            ]);

                            paramsHtml += '<div style="margin-top: 8px;"><strong>Parameters:</strong></div>';
                            paramsHtml += '<ul style="margin: 4px 0; padding-left: 20px;">';

                            let missingRequiredParams = [];

                            service.parameters.forEach(param => {
                                // Check if this parameter is defined in schema or internal args
                                let isDefined = false;
                                let definedWhere = '';

                                // Check direct match
                                if (allDefinedProps.has(param.name)) {
                                    isDefined = true;
                                    if (schemaProperties[param.name]) {
                                        definedWhere = 'âœ“ Schema';
                                    } else if (toolInternalArgs[param.name]) {
                                        definedWhere = 'âœ“ Internal';
                                    }
                                } else {
                                    // Check targetParam mappings
                                    for (const [propName, propDef] of Object.entries(schemaProperties)) {
                                        if (propDef.targetParam === param.name) {
                                            isDefined = true;
                                            definedWhere = `âœ“ Schema (via ${propName})`;
                                            break;
                                        }
                                    }
                                }

                                const isRequired = param.is_required;
                                const defaultVal = param.has_default && param.default !== null
                                    ? ` = ${JSON.stringify(param.default)}`
                                    : '';

                                const statusColor = isDefined ? '#28a745' : (isRequired ? '#dc3545' : '#ffc107');
                                const statusIcon = isDefined ? 'âœ“' : (isRequired ? 'âœ—' : 'â—‹');
                                const statusText = isDefined ? definedWhere : (isRequired ? 'Missing!' : 'Optional');

                                if (!isDefined && isRequired) {
                                    missingRequiredParams.push(param.name);
                                }

                                paramsHtml += `
                                    <li>
                                        <code>${param.name}: ${param.type}${defaultVal}</code>
                                        ${isRequired ? '<span style="color: #dc3545;"> *</span>' : ''}
                                        <span style="margin-left: 10px; color: ${statusColor}; font-weight: 600;">
                                            ${statusIcon} ${statusText}
                                        </span>
                                    </li>`;
                            });
                            paramsHtml += '</ul>';

                            // Show warning for missing required parameters
                            if (missingRequiredParams.length > 0) {
                                paramsHtml += `
                                    <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 8px; margin-top: 8px;">
                                        <strong style="color: #856404;">âš ï¸ Missing Required Parameters:</strong>
                                        <ul style="margin: 4px 0 0 0; padding-left: 20px;">
                                            ${missingRequiredParams.map(p => `<li style="color: #856404;">${p}</li>`).join('')}
                                        </ul>
                                        <div style="margin-top: 8px;">
                                            <button class="btn btn-sm btn-warning" onclick="addMissingParameters(${index}, ${JSON.stringify(missingRequiredParams).replace(/"/g, '&quot;')})">
                                                Add Missing Parameters
                                            </button>
                                        </div>
                                    </div>`;
                            }
                        } else {
                            paramsHtml += '<div style="margin-top: 8px;">No parameters defined</div>';
                        }

                        paramsDiv.innerHTML = paramsHtml;
                    } else {
                        paramsDiv.innerHTML = 'Service method not found in registry';
                    }
                })
                .catch(error => {
                    console.error('Failed to load service method params:', error);
                    paramsDiv.innerHTML = 'Failed to load parameters';
                });
        }

        function addMissingParameters(index, missingParams) {
            const tool = tools[index];

            if (!tool.inputSchema) {
                tool.inputSchema = { properties: {}, required: [] };
            }
            if (!tool.inputSchema.properties) {
                tool.inputSchema.properties = {};
            }

            // Add each missing parameter
            missingParams.forEach(paramName => {
                // Add to schema properties
                tool.inputSchema.properties[paramName] = {
                    type: 'string',  // Default type, should be updated based on actual parameter type
                    description: `Auto-added parameter for ${paramName}`
                };

                // Add to required if not already there
                if (!tool.inputSchema.required) {
                    tool.inputSchema.required = [];
                }
                if (!tool.inputSchema.required.includes(paramName)) {
                    tool.inputSchema.required.push(paramName);
                }
            });

            // Re-render the editor
            renderToolEditor(tool, index);
            showNotification(`Added ${missingParams.length} missing parameter(s)`, 'success');
        }

        function updateToolField(index, field, value) {
            const oldValue = tools[index][field];
            tools[index][field] = value;

            // If tool name is changed, update internal_args key as well
            if (field === 'name' && oldValue !== value) {
                if (internalArgs[oldValue]) {
                    internalArgs[value] = internalArgs[oldValue];
                    delete internalArgs[oldValue];
                    console.log(`Updated internal_args key: "${oldValue}" â†’ "${value}"`);
                }
            }

            renderToolList();
        }

        function updateMcpService(index, value) {
            updateToolField(index, 'mcp_service', value);
            applySignatureDefaults(index, value);
            renderToolEditor(tools[index], index);
        }

        // ============================================================
        // Internal Args Functions
        // ============================================================

        function getInternalArgDefaults(propArg) {
            // Extract default values from original_schema.properties
            if (!propArg || !propArg.original_schema || !propArg.original_schema.properties) {
                return {};
            }
            const defaults = {};
            for (const [key, prop] of Object.entries(propArg.original_schema.properties)) {
                if (prop.default !== undefined) {
                    defaults[key] = prop.default;
                }
            }
            return defaults;
        }

        function setPropertyDestination(index, propName, destination) {
            const tool = tools[index];
            const toolName = tool.name;
            const propDef = tool.inputSchema?.properties?.[propName];

            // For "to signature", check if we have stored original_schema
            const existingInternal = internalArgs[toolName]?.[propName];

            if (destination === 'internal') {
                // If already internal, nothing to do
                if (existingInternal && !propDef) {
                    console.log('Property already internal:', propName);
                    return;
                }
                if (!propDef) {
                    console.error('Property not found in inputSchema:', propName);
                    return;
                }

                // Move to Internal: add to internalArgs and REMOVE from inputSchema
                if (!internalArgs[toolName]) {
                    internalArgs[toolName] = {};
                }

                // Store original schema info for potential restoration
                const wasRequired = (tool.inputSchema.required || []).includes(propName);
                internalArgs[toolName][propName] = {
                    type: propDef.baseModel || propDef.type,  // Use baseModel if available
                    description: propDef.description || '',
                    original_schema: JSON.parse(JSON.stringify(propDef)),  // Deep copy for restoration
                    was_required: wasRequired
                };

                // CRITICAL: Remove from inputSchema.properties (spec FR-03)
                delete tool.inputSchema.properties[propName];

                // Remove from required array if present
                if (tool.inputSchema.required) {
                    tool.inputSchema.required = tool.inputSchema.required.filter(r => r !== propName);
                }

                showNotification(`Property "${propName}" moved to Internal (removed from MCP signature)`, 'info');
            } else {
                // Move to Signature: restore from internalArgs
                if (!existingInternal) {
                    console.error('No internal arg found to restore:', propName);
                    return;
                }

                // Restore original schema from stored original_schema
                if (existingInternal.original_schema) {
                    tool.inputSchema.properties[propName] = JSON.parse(JSON.stringify(existingInternal.original_schema));
                } else {
                    // Fallback: create basic schema from internal arg info
                    tool.inputSchema.properties[propName] = {
                        type: existingInternal.type === 'object' ? 'object' : existingInternal.type,
                        description: existingInternal.description || ''
                    };
                }

                // Restore required status if it was required before
                if (existingInternal.was_required) {
                    if (!tool.inputSchema.required) {
                        tool.inputSchema.required = [];
                    }
                    if (!tool.inputSchema.required.includes(propName)) {
                        tool.inputSchema.required.push(propName);
                    }
                }

                // Remove from internalArgs
                delete internalArgs[toolName][propName];

                // Clean up empty tool entry
                if (Object.keys(internalArgs[toolName]).length === 0) {
                    delete internalArgs[toolName];
                }

                showNotification(`Property "${propName}" restored to Signature`, 'info');
            }

            // Re-render to update UI (preserve scroll position and collapse state)
            const scrollContainer = document.querySelector('.editor-area');
            const scrollTop = scrollContainer
                ? scrollContainer.scrollTop
                : (window.scrollY || document.documentElement.scrollTop);
            const scrollLeft = scrollContainer
                ? scrollContainer.scrollLeft
                : (window.scrollX || document.documentElement.scrollLeft);

            // Save collapsed property states before re-render (class-based, not inline style)
            const collapsedProps = Array.from(document.querySelectorAll('.property-collapse-content'))
                .filter(content => content.classList.contains('collapsed'))
                .map(content => content.id);

            renderToolEditor(tool, index);

            // Restore collapsed states
            collapsedProps.forEach(id => {
                const content = document.getElementById(id);
                const iconId = id.replace('content-', 'icon-');
                const icon = document.getElementById(iconId);
                const headerId = id.replace('content-', 'header-');
                const header = document.getElementById(headerId);

                if (content) content.classList.add('collapsed');
                if (icon) {
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                }
                if (header) header.classList.remove('expanded');
            });

            // Restore scroll position after render (prefer the editor scroll container)
            setTimeout(() => {
                if (scrollContainer) {
                    scrollContainer.scrollTop = scrollTop;
                    scrollContainer.scrollLeft = scrollLeft;
                } else {
                    window.scrollTo(scrollLeft, scrollTop);
                }
            }, 10);
        }

        function updateInternalArgDefaults(index, propName, jsonString) {
            const tool = tools[index];
            const toolName = tool.name;

            if (!internalArgs[toolName] || !internalArgs[toolName][propName]) {
                console.error('Internal arg not found:', toolName, propName);
                return;
            }

            try {
                const defaults = JSON.parse(jsonString);
                // Update default values in original_schema.properties
                const propArg = internalArgs[toolName][propName];
                if (!propArg.original_schema.properties) {
                    propArg.original_schema.properties = {};
                }
                for (const [key, value] of Object.entries(defaults)) {
                    if (!propArg.original_schema.properties[key]) {
                        propArg.original_schema.properties[key] = { type: typeof value };
                    }
                    propArg.original_schema.properties[key].default = value;
                }
                showNotification(`Internal defaults updated for "${propName}"`, 'success');
            } catch (e) {
                showNotification(`Invalid JSON: ${e.message}`, 'error');
            }
        }

        // ============================================================
        // Property Field Functions
        // ============================================================

        function updatePropertyField(index, propName, field, value) {
            const tool = tools[index];
            const toolName = tool.name;

            // Check if this property is internal (not in inputSchema but in internalArgs)
            const isInternal = !tool.inputSchema.properties[propName] &&
                               internalArgs[toolName]?.[propName];

            if (isInternal) {
                // Update original_schema in internalArgs instead of inputSchema
                if (!internalArgs[toolName][propName].original_schema) {
                    internalArgs[toolName][propName].original_schema = {};
                }
                internalArgs[toolName][propName].original_schema[field] = value;

                // CRITICAL: Also update the main internal arg fields that the generator uses
                if (field === 'description') {
                    internalArgs[toolName][propName].description = value;
                }
                // Issue 10 fix: Update type in internalArgs so generator uses the new type
                if (field === 'type') {
                    // Only update if there's no baseModel (baseModel takes precedence)
                    if (!internalArgs[toolName][propName].original_schema?.baseModel) {
                        internalArgs[toolName][propName].type = value;
                    }
                }
                // Add targetParam to top level for internal args
                if (field === 'targetParam') {
                    if (value) {
                        internalArgs[toolName][propName].targetParam = value;
                    } else {
                        // Remove targetParam if value is empty
                        delete internalArgs[toolName][propName].targetParam;
                    }
                }
            } else {
                // Normal signature property - update inputSchema
                if (!tool.inputSchema.properties[propName]) {
                    tool.inputSchema.properties[propName] = {};
                }
                tool.inputSchema.properties[propName][field] = value;
            }

            // If targetParam was changed, update the service method params display
            if (field === 'targetParam') {
                loadAndDisplayServiceMethodParams(index);
            }
        }

        function updatePropertyEnum(index, propName, value) {
            const tool = tools[index];
            const toolName = tool.name;
            const enumValues = value.split(',').map(v => v.trim()).filter(v => v);

            // Check if this property is internal
            const isInternal = !tool.inputSchema.properties[propName] &&
                               internalArgs[toolName]?.[propName];

            if (isInternal) {
                if (!internalArgs[toolName][propName].original_schema) {
                    internalArgs[toolName][propName].original_schema = {};
                }
                internalArgs[toolName][propName].original_schema.enum = enumValues;
            } else {
                tool.inputSchema.properties[propName].enum = enumValues;
            }
        }

        function toggleEnum(index, propName, hasEnum) {
            const tool = tools[index];
            const toolName = tool.name;

            // Check if this property is internal
            const isInternal = !tool.inputSchema.properties[propName] &&
                               internalArgs[toolName]?.[propName];

            if (isInternal) {
                if (!internalArgs[toolName][propName].original_schema) {
                    internalArgs[toolName][propName].original_schema = {};
                }
                if (hasEnum) {
                    internalArgs[toolName][propName].original_schema.enum = [];
                } else {
                    delete internalArgs[toolName][propName].original_schema.enum;
                }
            } else {
                if (hasEnum) {
                    tool.inputSchema.properties[propName].enum = [];
                } else {
                    delete tool.inputSchema.properties[propName].enum;
                }
            }
            renderToolEditor(tool, index);
        }

        function toggleRequired(index, propName, isChecked) {
            const tool = tools[index];
            const toolName = tool.name;

            // Check if this property is internal
            const isInternal = !tool.inputSchema.properties[propName] &&
                               internalArgs[toolName]?.[propName];

            if (isInternal) {
                // For internal properties, update was_required in internalArgs
                internalArgs[toolName][propName].was_required = isChecked;
            } else {
                // Normal signature property - update inputSchema.required
                if (!tool.inputSchema.required) {
                    tool.inputSchema.required = [];
                }

                if (isChecked) {
                    if (!tool.inputSchema.required.includes(propName)) {
                        tool.inputSchema.required.push(propName);
                    }
                    // Required property cannot have default value - remove it
                    if (tool.inputSchema.properties[propName]) {
                        delete tool.inputSchema.properties[propName].default;
                    }
                } else {
                    tool.inputSchema.required = tool.inputSchema.required.filter(r => r !== propName);
                }
            }

            // Re-render to update the JSON view (this will show/hide default field)
            renderToolEditor(tool, index);
        }

        function parseDefaultValue(value, type) {
            if (value === '' || value === undefined) return undefined;
            switch (type) {
                case 'integer':
                    return parseInt(value, 10);
                case 'number':
                    return parseFloat(value);
                case 'boolean':
                    return value === 'true' || value === true;
                case 'object':
                case 'array':
                    // Parse JSON for object and array types
                    if (typeof value === 'string') {
                        try {
                            return JSON.parse(value);
                        } catch (e) {
                            console.error('Invalid JSON for default value:', e.message);
                            return undefined;
                        }
                    }
                    return value;
                default:
                    return value;
            }
        }

        function formatDefaultValue(value, type) {
            // Format default value for display in input field
            if (value === undefined || value === null) return '';
            if (type === 'object' || type === 'array') {
                return typeof value === 'string' ? value : JSON.stringify(value, null, 2);
            }
            return String(value);
        }

        function addProperty(index) {
            // Remove any existing property modal first
            const existingModal = document.getElementById('propertyModal');
            if (existingModal) {
                existingModal.parentElement.remove();
            }

            // Create modal for property selection
            const hasTypes = window.hasTypesFile || false;
            const typesName = window.typesName || 'types';
            const modalHtml = `
                <div id="propertyModal" class="modal show">
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header">
                            <h3>Add Property</h3>
                            <button onclick="closeModal('propertyModal')" class="close-btn">Ã—</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Property Source</label>
                                <select id="propertySource" onchange="handlePropertySourceChange()" class="form-control">
                                    <option value="custom">Custom Property</option>
                                    ${hasTypes ? `<option value="graph_types">From ${typesName}.py</option>` : ''}
                                </select>
                            </div>

                            <div id="customPropertyDiv">
                                <div class="form-group">
                                    <label>Input Schema Name</label>
                                    <input type="text" id="customPropName" class="form-control" placeholder="e.g., filter_params, user_email, search_term">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                        This name will be used in inputSchema.properties for LLM to recognize.
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label>Service Method Parameter (optional)</label>
                                    <select id="customTargetParam" class="form-control">
                                        <option value="">-- Same as Input Schema Name --</option>
                                    </select>
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                        Select which parameter in the service method this property maps to. Leave default if names match.
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label>Property Type</label>
                                    <select id="customPropType" class="form-control" onchange="handleCustomTypeChange()">
                                        <option value="string">string</option>
                                        <option value="integer">integer</option>
                                        <option value="number">number</option>
                                        <option value="boolean">boolean</option>
                                        <option value="array">array</option>
                                        <option value="object">object</option>
                                    </select>
                                </div>
                                <div class="form-group" id="customBaseModelDiv" style="display: none;">
                                    <label>Base Model (for object type)</label>
                                    <input type="text" id="customBaseModel" class="form-control" placeholder="e.g., FilterParams, ExcludeParams">
                                </div>
                                <div class="form-group">
                                    <label>Description</label>
                                    <input type="text" id="customPropDescription" class="form-control" placeholder="Property description">
                                </div>
                            </div>

                            <div id="graphTypesPropertyDiv" style="display: none;">
                                <div class="form-group">
                                    <label>Select Type (from ${typesName}.py)</label>
                                    <select id="graphTypeClass" onchange="handleClassChange()" class="form-control" data-debug-id="FIELD_GRAPH_TYPE_CLASS">
                                        <option value="">-- Select Type --</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Input Schema Name (optional)</label>
                                    <input type="text" id="graphTypePropName" class="form-control"
                                           placeholder="e.g., filter_params, exclude_params">
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                        The name that will appear in inputSchema.properties. Leave empty for automatic naming. Use _internal suffix for internal-only objects.
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label>Service Method Parameter (optional)</label>
                                    <select id="graphTypeTargetParam" class="form-control">
                                        <option value="">-- Same as Input Schema Name --</option>
                                    </select>
                                    <div style="font-size: 11px; color: var(--text-secondary); margin-top: 4px;">
                                        Select which parameter in the service method this property maps to. Leave default if names match.
                                    </div>
                                </div>
                                <div class="form-group" id="propertySelectionDiv" style="display: none;">
                                    <label>Select Properties to Add</label>
                                    <div style="border: 1px solid #ddd; border-radius: 4px; padding: 10px; max-height: 300px; overflow-y: auto;">
                                        <div id="propertyCheckboxList">
                                            <!-- Checkboxes will be populated here -->
                                        </div>
                                    </div>
                                    <div style="margin-top: 10px;">
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="selectAllProperties(true)">Select All</button>
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="selectAllProperties(false)">Deselect All</button>
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleAllRequired(true)">All Required</button>
                                        <button type="button" class="btn btn-sm btn-secondary" onclick="toggleAllRequired(false)">All Optional</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button onclick="confirmAddProperty(${index})" class="btn btn-primary">Add Property</button>
                            <button onclick="closeModal('propertyModal')" class="btn btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to body
            const modalDiv = document.createElement('div');
            modalDiv.innerHTML = modalHtml;
            document.body.appendChild(modalDiv);

            // Populate graph type class dropdown if types are available
            if (hasTypes && window.graphTypesProperties && window.graphTypesProperties.classes) {
                const classSelect = document.getElementById('graphTypeClass');
                window.graphTypesProperties.classes.forEach(cls => {
                    const option = document.createElement('option');
                    option.value = cls.name || cls;
                    option.textContent = `${cls.name || cls}${cls.description ? ' (' + cls.description + ')' : ''}`;
                    classSelect.appendChild(option);
                });
                console.log('[DEBUG] Populated graph type classes:', window.graphTypesProperties.classes.length, 'classes');
            } else {
                console.log('[DEBUG] No graph types available. hasTypes:', hasTypes, 'graphTypesProperties:', window.graphTypesProperties);
            }

            // Initialize the property source view to show custom property fields by default
            handlePropertySourceChange();

            // Load service method parameters for the dropdown
            loadServiceMethodParameters(index);
        }

        function loadServiceMethodParameters(index) {
            const tool = tools[index];
            const toolName = tool.name;

            // Try both select elements (custom and graph types)
            const customSelect = document.getElementById('customTargetParam');
            const graphSelect = document.getElementById('graphTypeTargetParam');

            const selects = [customSelect, graphSelect].filter(s => s);

            // Clear existing options except the default one for all selects
            selects.forEach(select => {
                select.innerHTML = '<option value="">-- Same as Input Schema Name --</option>';
            });

            // Try to get the service implementation info
            if (tool.mcp_service) {
                // Get the service name from tool definition
                const serviceName = typeof tool.mcp_service === 'string'
                    ? tool.mcp_service
                    : tool.mcp_service.name;

                // Load the registry to get actual method parameters
                const currentProfile = window.currentProfile || 'mcp_outlook';
                fetch(`/api/registry?profile=${currentProfile}`)
                    .then(response => response.json())
                    .then(registry => {
                        if (registry && registry.services && registry.services[serviceName]) {
                            const service = registry.services[serviceName];
                            if (service.parameters) {
                                service.parameters.forEach(param => {
                                    selects.forEach(select => {
                                        const option = document.createElement('option');
                                        option.value = param.name;
                                        option.textContent = `${param.name} (${param.type})`;
                                        select.appendChild(option);
                                    });
                                });
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Failed to load service parameters:', error);
                    });
            }
        }

        function handleCustomTypeChange() {
            const propType = document.getElementById('customPropType').value;
            const baseModelDiv = document.getElementById('customBaseModelDiv');

            // Show base model input only for object type
            baseModelDiv.style.display = propType === 'object' ? 'block' : 'none';
        }

        function handlePropertySourceChange() {
            const source = document.getElementById('propertySource').value;
            document.getElementById('customPropertyDiv').style.display = source === 'custom' ? 'block' : 'none';
            document.getElementById('graphTypesPropertyDiv').style.display = source === 'graph_types' ? 'block' : 'none';

            console.log('[DEBUG] Property source changed to:', source);

            if (source === 'graph_types') {
                const classSelect = document.getElementById('graphTypeClass');
                if (!classSelect) return;

                const populate = () => {
                    if (classSelect.options.length <= 1) {
                        populateGraphTypeOptions(classSelect);
                    }
                };

                if (window.graphTypesProperties && Array.isArray(window.graphTypesProperties.classes)) {
                    populate();
                } else {
                    loadGraphTypesProperties().then(populate);
                }
            }
        }

        function handleClassChange() {
            const className = document.getElementById('graphTypeClass').value;
            const selectionDiv = document.getElementById('propertySelectionDiv');
            const checkboxList = document.getElementById('propertyCheckboxList');
            const propNameInput = document.getElementById('graphTypePropName');

            console.log('[DEBUG] handleClassChange called. className:', className);
            console.log('[DEBUG] window.graphTypesProperties:', window.graphTypesProperties);

            if (className && window.graphTypesProperties) {
                if (propNameInput) {
                    const tool = tools[currentToolIndex];
                    const defaultName = tool ? getTargetPropertyForGraphType(className, tool) : null;
                    propNameInput.placeholder = defaultName ? `Default: ${defaultName}` : 'Enter property name';
                }
                const properties = window.graphTypesProperties.properties_by_class[className] || [];
                console.log('[DEBUG] Found properties for', className, ':', properties.length, 'properties');

                // Generate checkboxes for each property
                let checkboxHtml = '';
                properties.forEach((prop, idx) => {
                    const propId = `prop_${className}_${idx}`;
                    const reqId = `req_${className}_${idx}`;
                    checkboxHtml += `
                        <div style="padding: 8px; border-bottom: 1px solid #eee; display: flex; align-items: center;">
                            <input type="checkbox" id="${propId}" data-prop-name="${prop.name}"
                                   data-prop-type="${prop.type}" data-prop-desc="${prop.description || ''}"
                                   style="margin-right: 10px;">
                            <div style="flex-grow: 1;">
                                <label for="${propId}" style="margin: 0; cursor: pointer;">
                                    <strong>${prop.name}</strong>
                                    <span style="color: #666; font-size: 12px;">(${prop.type})</span>
                                    ${prop.description ? `<br><span style="color: #888; font-size: 11px;">${prop.description}</span>` : ''}
                                </label>
                            </div>
                            <div style="margin-left: 10px;">
                                <label style="margin: 0; font-size: 12px;">
                                    <input type="checkbox" id="${reqId}" style="margin-right: 5px;">Required
                                </label>
                            </div>
                        </div>
                    `;
                });

                checkboxList.innerHTML = checkboxHtml || '<div style="padding: 10px; text-align: center; color: #666;">No properties available</div>';
                selectionDiv.style.display = 'block';
            } else {
                if (propNameInput) {
                    propNameInput.placeholder = 'Leave empty to use default mapping';
                }
                console.log('[DEBUG] Hiding property selection. className:', className, 'graphTypesProperties:', !!window.graphTypesProperties);
                selectionDiv.style.display = 'none';
            }
        }

        function selectAllProperties(select) {
            const checkboxes = document.querySelectorAll('#propertyCheckboxList input[type="checkbox"][id^="prop_"]');
            checkboxes.forEach(cb => cb.checked = select);
        }

        function toggleAllRequired(required) {
            const checkboxes = document.querySelectorAll('#propertyCheckboxList input[type="checkbox"][id^="req_"]');
            checkboxes.forEach(cb => cb.checked = required);
        }

        function openNestedGraphTypesModal(toolIndex, propName) {
            nestedGraphTarget = {toolIndex, propName};

            const classSelect = document.getElementById('nestedGraphTypeClass');
            const selectionDiv = document.getElementById('nestedPropertySelectionDiv');
            const checkboxList = document.getElementById('nestedPropertyCheckboxList');

            classSelect.value = '';
            checkboxList.innerHTML = '';
            selectionDiv.style.display = 'none';

            populateGraphTypeOptions(classSelect);

            const tool = tools[toolIndex];
            const toolName = tool.name;
            let parentProp = tool.inputSchema?.properties?.[propName];
            if (!parentProp && internalArgs[toolName]?.[propName]) {
                parentProp = internalArgs[toolName][propName].original_schema;
            }
            if (parentProp && parentProp.baseModel) {
                classSelect.value = parentProp.baseModel;
                handleNestedGraphClassChange();
            }

            document.getElementById('nestedGraphTypesModal').classList.add('show');
        }

        function handleNestedGraphClassChange() {
            const className = document.getElementById('nestedGraphTypeClass').value;
            const selectionDiv = document.getElementById('nestedPropertySelectionDiv');
            const checkboxList = document.getElementById('nestedPropertyCheckboxList');

            if (className && window.graphTypesProperties) {
                const properties = window.graphTypesProperties.properties_by_class[className] || [];

                let checkboxHtml = '';
                properties.forEach((prop, idx) => {
                    const propId = `nested_prop_${className}_${idx}`;
                    const reqId = `nested_req_${className}_${idx}`;
                    checkboxHtml += `
                        <div style="padding: 8px; border-bottom: 1px solid #eee; display: flex; align-items: center;">
                            <input type="checkbox" id="${propId}" data-prop-name="${prop.name}"
                                   data-prop-type="${prop.type}" data-prop-desc="${prop.description || ''}"
                                   style="margin-right: 10px;">
                            <div style="flex-grow: 1;">
                                <label for="${propId}" style="margin: 0; cursor: pointer;">
                                    <strong>${prop.name}</strong>
                                    <span style="color: #666; font-size: 12px;">(${prop.type})</span>
                                    ${prop.description ? `<br><span style="color: #888; font-size: 11px;">${prop.description}</span>` : ''}
                                </label>
                            </div>
                            <div style="margin-left: 10px;">
                                <label style="margin: 0; font-size: 12px;">
                                    <input type="checkbox" id="${reqId}" style="margin-right: 5px;">Required
                                </label>
                            </div>
                        </div>
                    `;
                });

                checkboxList.innerHTML = checkboxHtml || '<div style="padding: 10px; text-align: center; color: #666;">No properties available</div>';
                selectionDiv.style.display = 'block';
            } else {
                selectionDiv.style.display = 'none';
                checkboxList.innerHTML = '';
            }
        }

        function selectAllNestedProperties(select) {
            const checkboxes = document.querySelectorAll('#nestedPropertyCheckboxList input[type="checkbox"][id^="nested_prop_"]');
            checkboxes.forEach(cb => cb.checked = select);
        }

        function toggleAllNestedRequired(required) {
            const checkboxes = document.querySelectorAll('#nestedPropertyCheckboxList input[type="checkbox"][id^="nested_req_"]');
            checkboxes.forEach(cb => cb.checked = required);
        }

        function confirmAddNestedGraphProperties() {
            if (!nestedGraphTarget) {
                closeModal('nestedGraphTypesModal');
                return;
            }

            const className = document.getElementById('nestedGraphTypeClass').value;
            const checkboxes = document.querySelectorAll('#nestedPropertyCheckboxList input[type="checkbox"][id^="nested_prop_"]:checked');

            if (!className) {
                showNotification('Please select a type from outlook_types.py', 'error');
                return;
            }

            if (checkboxes.length === 0) {
                showNotification('Please select at least one property', 'error');
                return;
            }

            const {toolIndex, propName} = nestedGraphTarget;
            const tool = tools[toolIndex];
            const toolName = tool.name;
            const internalArg = internalArgs[toolName]?.[propName];
            const useInternal = !!internalArg;
            let parentProp;

            if (useInternal) {
                if (!internalArg.original_schema) {
                    internalArg.original_schema = {type: 'object', properties: {}, required: []};
                }
                parentProp = internalArg.original_schema;
                internalArg.type = className;
                if (!internalArg.description && parentProp.description) {
                    internalArg.description = parentProp.description;
                }
            } else {
                if (!tool.inputSchema) {
                    tool.inputSchema = {type: 'object', properties: {}, required: []};
                }
                if (!tool.inputSchema.properties) {
                    tool.inputSchema.properties = {};
                }
                if (!tool.inputSchema.properties[propName]) {
                    tool.inputSchema.properties[propName] = {type: 'object', properties: {}, required: []};
                }
                parentProp = tool.inputSchema.properties[propName];
            }
            parentProp.type = 'object';
            parentProp.properties = parentProp.properties || {};
            parentProp.required = parentProp.required || [];
            parentProp.baseModel = parentProp.baseModel || className;
            if (!parentProp.description) {
                parentProp.description = `${className} parameters`;
            }
            if (useInternal && !internalArg.description) {
                internalArg.description = parentProp.description;
            }

            let addedCount = 0;
            checkboxes.forEach(cb => {
                const prop = cb.dataset;
                const idx = cb.id.split('_').pop();
                const isRequired = document.getElementById(`nested_req_${className}_${idx}`).checked;

                parentProp.properties[prop.propName] = {
                    type: mapToJsonSchemaType(prop.propType),
                    description: prop.propDesc || ''
                };

                if (isRequired && !parentProp.required.includes(prop.propName)) {
                    parentProp.required.push(prop.propName);
                }

                addedCount++;
            });

            closeModal('nestedGraphTypesModal');
            renderToolEditor(tool, toolIndex);
            showNotification(`${addedCount} nested properties added to "${propName}"`, 'success');
        }

        function confirmAddProperty(index) {
            const source = document.getElementById('propertySource').value;

            if (source === 'custom') {
                // Handle single custom property
                const propName = document.getElementById('customPropName').value;
                const propType = document.getElementById('customPropType').value;
                const propDescription = document.getElementById('customPropDescription').value;
                const targetParam = document.getElementById('customTargetParam').value;
                const baseModel = document.getElementById('customBaseModel').value;

                if (propName) {
                    if (!tools[index].inputSchema.properties) {
                        tools[index].inputSchema.properties = {};
                    }

                    // Check if property already exists
                    if (tools[index].inputSchema.properties[propName]) {
                        if (!confirm(`Property "${propName}" already exists. Do you want to overwrite it?`)) {
                            return;
                        }
                    }

                    // For custom properties, use simple type
                    const jsonType = mapToJsonSchemaType(propType);
                    const propDef = {
                        type: jsonType,
                        description: propDescription
                    };

                    // Add targetParam if specified and different from propName
                    if (targetParam && targetParam.trim() && targetParam !== propName) {
                        propDef.targetParam = targetParam.trim();
                    }

                    // Add baseModel for object types
                    if (jsonType === 'object' && baseModel && baseModel.trim()) {
                        propDef.baseModel = baseModel.trim();
                    }

                    tools[index].inputSchema.properties[propName] = propDef;

                    closeModal('propertyModal');
                    renderToolEditor(tools[index], index);
                    showNotification(`Property "${propName}" added successfully`, 'success');
                } else {
                    showNotification('Please enter a property name', 'error');
                }
            } else {
                // Handle multiple properties from graph_types
                const className = document.getElementById('graphTypeClass').value;
                const checkboxes = document.querySelectorAll('#propertyCheckboxList input[type="checkbox"][id^="prop_"]:checked');

                if (!className) {
                    showNotification('Please select a type from outlook_types.py', 'error');
                    return;
                }

                if (checkboxes.length === 0) {
                    showNotification('Please select at least one property', 'error');
                    return;
                }

                if (!tools[index].inputSchema.properties) {
                    tools[index].inputSchema.properties = {};
                }
                if (!tools[index].inputSchema.required) {
                    tools[index].inputSchema.required = [];
                }

                let addedCount = 0;
                const overridePropName = document.getElementById('graphTypePropName')?.value.trim();
                const targetPropName = overridePropName || getTargetPropertyForGraphType(className, tools[index]);

                if (!targetPropName && overridePropName) {
                    showNotification('Please enter a property name', 'error');
                    return;
                }

                if (targetPropName) {
                    const toolName = tools[index].name;
                    // Check if target property is internal
                    const isTargetInternal = !tools[index].inputSchema.properties[targetPropName] &&
                                             internalArgs[toolName]?.[targetPropName];

                    let targetProp;  // Declare outside if blocks for shared access

                    if (isTargetInternal) {
                        // Update internalArgs for internal property (Issue 10 fix)
                        if (!internalArgs[toolName][targetPropName].original_schema) {
                            internalArgs[toolName][targetPropName].original_schema = {
                                type: 'object',
                                description: `${className} parameters`,
                                properties: {},
                                required: []
                            };
                        }
                        targetProp = internalArgs[toolName][targetPropName].original_schema;
                        targetProp.type = 'object';
                        targetProp.properties = targetProp.properties || {};
                        targetProp.required = targetProp.required || [];
                        targetProp.baseModel = className;
                        // CRITICAL: Update internalArgs.type for generator
                        internalArgs[toolName][targetPropName].type = className;
                        if (!targetProp.description) {
                            targetProp.description = `${className} parameters`;
                        }
                    } else {
                        // Normal signature property
                        if (!tools[index].inputSchema.properties[targetPropName]) {
                            tools[index].inputSchema.properties[targetPropName] = {
                                type: 'object',
                                description: `${className} parameters`,
                                properties: {},
                                required: []
                            };
                        }

                        targetProp = tools[index].inputSchema.properties[targetPropName];
                        targetProp.type = 'object';
                        targetProp.properties = targetProp.properties || {};
                        targetProp.required = targetProp.required || [];
                        targetProp.baseModel = className;
                        if (!targetProp.description) {
                            targetProp.description = `${className} parameters`;
                        }

                        // Add targetParam if specified and different from targetPropName
                        const customTargetParam = document.getElementById('graphTypeTargetParam')?.value;
                        if (customTargetParam && customTargetParam.trim() && customTargetParam !== targetPropName) {
                            targetProp.targetParam = customTargetParam.trim();
                        }
                    }

                    checkboxes.forEach(checkbox => {
                        const propName = checkbox.dataset.propName;
                        const propType = checkbox.dataset.propType;
                        const propDesc = checkbox.dataset.propDesc;
                        const idx = checkbox.id.split('_').pop();
                        const isRequired = document.getElementById(`req_${className}_${idx}`).checked;

                        targetProp.properties[propName] = {
                            type: mapToJsonSchemaType(propType),
                            description: propDesc || ''
                        };

                        if (isRequired && !targetProp.required.includes(propName)) {
                            targetProp.required.push(propName);
                        }

                        addedCount++;
                    });
                } else {
                    // Fallback: add to top-level properties (legacy behavior)
                    checkboxes.forEach(checkbox => {
                        const propName = checkbox.dataset.propName;
                        const propType = checkbox.dataset.propType;
                        const propDesc = checkbox.dataset.propDesc;
                        const idx = checkbox.id.split('_').pop();
                        const isRequired = document.getElementById(`req_${className}_${idx}`).checked;

                        tools[index].inputSchema.properties[propName] = {
                            type: mapToJsonSchemaType(propType),
                            description: propDesc || ''
                        };

                        if (isRequired && !tools[index].inputSchema.required.includes(propName)) {
                            tools[index].inputSchema.required.push(propName);
                        }

                        addedCount++;
                    });
                }

                closeModal('propertyModal');
                renderToolEditor(tools[index], index);
                showNotification(`${addedCount} properties added successfully${targetPropName ? ` to "${targetPropName}"` : ''}`, 'success');
            }
        }

        function mapToJsonSchemaType(type) {
            // Map Python/graph_types types to JSON Schema types
            const typeMap = {
                'string': 'string',
                'str': 'string',
                'integer': 'integer',
                'int': 'integer',
                'number': 'number',
                'float': 'number',
                'boolean': 'boolean',
                'bool': 'boolean',
                'array': 'array',
                'object': 'object',
                'any': 'string'
            };
            return typeMap[type] || 'string';
        }

        function mapSignatureTypeToSchema(typeStr) {
            if (!typeStr) {
                return { type: 'string' };
            }

            let optional = false;
            let innerType = typeStr;

            if (typeStr.startsWith('Optional[')) {
                optional = true;
                innerType = typeStr.slice(9, -1);
            }

            if (innerType.startsWith('List[') || innerType.startsWith('list[')) {
                const itemType = innerType.slice(5, -1);
                const mapped = mapSignatureTypeToSchema(itemType);
                return {
                    type: 'array',
                    items: { type: mapped.type || 'string' },
                    optional
                };
            }

            const typeMap = {
                'str': 'string',
                'int': 'integer',
                'float': 'number',
                'bool': 'boolean',
                'Dict': 'object',
                'dict': 'object',
                'Any': 'string',
                'FilterParams': 'object',
                'ExcludeParams': 'object',
                'SelectParams': 'object'
            };

            return {
                type: typeMap[innerType] || 'object',
                description: ['FilterParams', 'ExcludeParams', 'SelectParams'].includes(innerType)
                    ? `${innerType} parameters`
                    : '',
                optional
            };
        }

        function applySignatureDefaults(index, serviceName) {
            if (!serviceName || !window.mcpServiceDetails) {
                return;
            }

            const detail = window.mcpServiceDetails.find(svc => svc.name === serviceName);
            if (!detail || !Array.isArray(detail.parameters)) {
                return;
            }

            const tool = tools[index];
            if (!tool.inputSchema) {
                tool.inputSchema = { type: 'object', properties: {}, required: [] };
            }

            const existingProps = Object.keys(tool.inputSchema.properties || {});
            if (existingProps.length > 0) {
                return; // avoid overriding when schema already exists
            }

            tool.inputSchema.type = 'object';
            tool.inputSchema.properties = {};
            tool.inputSchema.required = [];

            detail.parameters.forEach(param => {
                if (!param || param.name === 'self') {
                    return;
                }

                const schema = mapSignatureTypeToSchema(param.type);
                tool.inputSchema.properties[param.name] = {
                    type: schema.type || 'string',
                    description: schema.description || ''
                };

                const hasDefault = param.default !== null && param.default !== undefined;
                const isOptional = param.type && param.type.startsWith('Optional[');
                if (!hasDefault && !isOptional) {
                    if (!tool.inputSchema.required.includes(param.name)) {
                        tool.inputSchema.required.push(param.name);
                    }
                }
            });

            showNotification(`Input schema pre-filled from ${serviceName} signature`, 'success');
        }

        function getTargetPropertyForGraphType(className, tool) {
            const mapping = {
                'FilterParams': ['filter'],
                'ExcludeParams': ['exclude', 'client_filter'],
                'SelectParams': ['select']
            };

            const candidates = mapping[className];
            if (!candidates || candidates.length === 0) {
                return null;
            }

            const internalProps = internalArgs[tool.name] || {};
            const schemaProps = tool.inputSchema?.properties || {};

            // Prefer an existing property match
            for (const candidate of candidates) {
                if (schemaProps[candidate] || internalProps[candidate]) {
                    return candidate;
                }
            }

            // Otherwise, use the primary candidate to create a new object
            return candidates[0];
        }

        function renameSchemaProperty(index, oldName, newName, inputElement) {
            // Trim and validate new name
            newName = newName.trim();

            // If name hasn't changed, do nothing
            if (oldName === newName) {
                return;
            }

            // Validate new name
            if (!newName) {
                showNotification('Property name cannot be empty', 'error');
                inputElement.value = oldName;
                return;
            }

            // Check for invalid characters (only allow alphanumeric and underscore)
            if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(newName)) {
                showNotification('Property name must start with a letter or underscore and contain only alphanumeric characters and underscores', 'error');
                inputElement.value = oldName;
                return;
            }

            const tool = tools[index];
            const toolName = tool.name;

            // Check if new name already exists
            if (tool.inputSchema.properties[newName] && newName !== oldName) {
                showNotification(`Property "${newName}" already exists`, 'error');
                inputElement.value = oldName;
                return;
            }

            // Check if it's an internal property
            const isInternal = !tool.inputSchema.properties[oldName] && internalArgs[toolName]?.[oldName];

            if (isInternal) {
                // Rename in internalArgs
                if (internalArgs[toolName] && internalArgs[toolName][oldName]) {
                    internalArgs[toolName][newName] = internalArgs[toolName][oldName];
                    delete internalArgs[toolName][oldName];
                }
            } else {
                // Rename in inputSchema.properties
                if (tool.inputSchema.properties[oldName]) {
                    tool.inputSchema.properties[newName] = tool.inputSchema.properties[oldName];
                    delete tool.inputSchema.properties[oldName];

                    // Update required array if needed
                    if (tool.inputSchema.required) {
                        const reqIndex = tool.inputSchema.required.indexOf(oldName);
                        if (reqIndex !== -1) {
                            tool.inputSchema.required[reqIndex] = newName;
                        }
                    }
                }
            }

            // Update the data-original-name attribute for future renames
            inputElement.dataset.originalName = newName;

            // Re-render the tool editor to reflect changes
            renderToolEditor(tool, index);
            showNotification(`Property renamed from "${oldName}" to "${newName}"`, 'success');
        }

        function removeProperty(index, propName) {
            if (confirm(`Remove property "${propName}"?`)) {
                const tool = tools[index];
                const toolName = tool.name;

                // Remove from inputSchema.properties if present
                delete tool.inputSchema.properties[propName];

                // Remove from required if present
                if (tool.inputSchema.required) {
                    tool.inputSchema.required = tool.inputSchema.required.filter(r => r !== propName);
                }

                // CRITICAL: Also remove from internalArgs if present (Issue 9 fix)
                if (internalArgs[toolName]?.[propName]) {
                    delete internalArgs[toolName][propName];
                    // Clean up empty tool entry
                    if (Object.keys(internalArgs[toolName]).length === 0) {
                        delete internalArgs[toolName];
                    }
                    showNotification(`Property "${propName}" removed from both schema and internal args`, 'info');
                }

                renderToolEditor(tool, index);
            }
        }

        // ============================================================
        // Nested Property Functions
        // ============================================================

        function toggleAllNestedCheckboxes(toolIndex, parentPropName, checked) {
            const checkboxes = document.querySelectorAll(
                `.nested-prop-checkbox[data-tool-index="${toolIndex}"][data-parent-prop="${parentPropName}"]`
            );
            checkboxes.forEach(cb => cb.checked = checked);
        }

        function updateNestedSelectAllState(toolIndex, parentPropName) {
            const checkboxes = document.querySelectorAll(
                `.nested-prop-checkbox[data-tool-index="${toolIndex}"][data-parent-prop="${parentPropName}"]`
            );
            const selectAllId = `nested-select-all-${toolIndex}-${parentPropName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            const selectAllCheckbox = document.getElementById(selectAllId);

            if (selectAllCheckbox && checkboxes.length > 0) {
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                const someChecked = Array.from(checkboxes).some(cb => cb.checked);
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = someChecked && !allChecked;
            }
        }

        function removeSelectedNestedProperties(toolIndex, parentPropName) {
            const checkboxes = document.querySelectorAll(
                `.nested-prop-checkbox[data-tool-index="${toolIndex}"][data-parent-prop="${parentPropName}"]:checked`
            );

            if (checkboxes.length === 0) {
                showNotification('No properties selected', 'warning');
                return;
            }

            const selectedProps = Array.from(checkboxes).map(cb => cb.dataset.nestedProp);

            if (confirm(`Remove ${selectedProps.length} nested properties?\n\n${selectedProps.join(', ')}`)) {
                const tool = tools[toolIndex];
                const toolName = tool.name;

                // Check if parent is in inputSchema or internalArgs
                let parentProp = tool.inputSchema.properties?.[parentPropName];
                let isInternal = false;

                if (!parentProp && internalArgs[toolName]?.[parentPropName]) {
                    parentProp = internalArgs[toolName][parentPropName].original_schema;
                    isInternal = true;
                }

                if (parentProp && parentProp.properties) {
                    selectedProps.forEach(nestedPropName => {
                        delete parentProp.properties[nestedPropName];

                        // Remove from required array if present
                        if (parentProp.required) {
                            parentProp.required = parentProp.required.filter(r => r !== nestedPropName);
                        }
                    });

                    showNotification(`Removed ${selectedProps.length} nested properties`, 'info');
                    renderToolEditor(tool, toolIndex);
                }
            }
        }

        function removeNestedPropertyInline(toolIndex, parentPropName, nestedPropName) {
            if (confirm(`Remove nested property "${nestedPropName}" from "${parentPropName}"?`)) {
                const tool = tools[toolIndex];
                const toolName = tool.name;

                // Check if parent is in inputSchema or internalArgs
                let parentProp = tool.inputSchema.properties?.[parentPropName];
                let isInternal = false;

                if (!parentProp && internalArgs[toolName]?.[parentPropName]) {
                    parentProp = internalArgs[toolName][parentPropName].original_schema;
                    isInternal = true;
                }

                if (parentProp && parentProp.properties) {
                    delete parentProp.properties[nestedPropName];

                    // Remove from required array if present
                    if (parentProp.required) {
                        parentProp.required = parentProp.required.filter(r => r !== nestedPropName);
                    }

                    showNotification(`Nested property "${nestedPropName}" removed`, 'info');
                    renderToolEditor(tool, toolIndex);
                }
            }
        }

        function toggleNestedRequired(toolIndex, parentPropName, nestedPropName, isChecked) {
            const tool = tools[toolIndex];
            const toolName = tool.name;
            const internalArg = internalArgs[toolName]?.[parentPropName];
            const isInternal = !tool.inputSchema.properties[parentPropName] && internalArg;
            let parentProp = tool.inputSchema.properties[parentPropName];

            if (isInternal) {
                if (!internalArg.original_schema) {
                    internalArg.original_schema = {type: 'object', properties: {}, required: []};
                }
                parentProp = internalArg.original_schema;
            }

            if (parentProp) {
                if (!parentProp.required) {
                    parentProp.required = [];
                }

                if (isChecked) {
                    if (!parentProp.required.includes(nestedPropName)) {
                        parentProp.required.push(nestedPropName);
                    }
                } else {
                    parentProp.required = parentProp.required.filter(r => r !== nestedPropName);
                }

                renderToolEditor(tool, toolIndex);
            }
        }

        function updateNestedPropertyType(toolIndex, parentPropName, nestedPropName, newType) {
            const tool = tools[toolIndex];
            const toolName = tool.name;
            const internalArg = internalArgs[toolName]?.[parentPropName];
            const isInternal = !tool.inputSchema.properties[parentPropName] && internalArg;
            let parentProp = tool.inputSchema.properties[parentPropName];

            if (isInternal) {
                if (!internalArg.original_schema) {
                    internalArg.original_schema = {type: 'object', properties: {}, required: []};
                }
                parentProp = internalArg.original_schema;
            }

            if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                parentProp.properties[nestedPropName].type = newType;
                // Clear type-specific properties when type changes
                delete parentProp.properties[nestedPropName].items;
                delete parentProp.properties[nestedPropName].enum;
                delete parentProp.properties[nestedPropName].properties;
            }
        }

        function updateNestedPropertyDescription(toolIndex, parentPropName, nestedPropName, description) {
            const tool = tools[toolIndex];
            const toolName = tool.name;

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                if (internalArg.original_schema?.properties?.[nestedPropName]) {
                    internalArg.original_schema.properties[nestedPropName].description = description;
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    parentProp.properties[nestedPropName].description = description;
                }
            }
        }

        function updateNestedPropertyDefault(toolIndex, parentPropName, nestedPropName, defaultValue) {
            const tool = tools[toolIndex];
            const toolName = tool.name;

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                // Ensure original_schema and properties structure exists
                if (!internalArg.original_schema) {
                    internalArg.original_schema = { type: 'object', properties: {} };
                }
                if (!internalArg.original_schema.properties) {
                    internalArg.original_schema.properties = {};
                }
                if (!internalArg.original_schema.properties[nestedPropName]) {
                    internalArg.original_schema.properties[nestedPropName] = { type: 'string' };
                }
                if (defaultValue === undefined) {
                    delete internalArg.original_schema.properties[nestedPropName].default;
                } else {
                    internalArg.original_schema.properties[nestedPropName].default = defaultValue;
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    if (defaultValue === undefined) {
                        delete parentProp.properties[nestedPropName].default;
                    } else {
                        parentProp.properties[nestedPropName].default = defaultValue;
                    }
                }
            }
        }

        function updateNestedPropertyFormat(toolIndex, parentPropName, nestedPropName, format) {
            const tool = tools[toolIndex];
            const toolName = tool.name;

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                if (internalArg.original_schema?.properties?.[nestedPropName]) {
                    if (format) {
                        internalArg.original_schema.properties[nestedPropName].format = format;
                    } else {
                        delete internalArg.original_schema.properties[nestedPropName].format;
                    }
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    if (format) {
                        parentProp.properties[nestedPropName].format = format;
                    } else {
                        delete parentProp.properties[nestedPropName].format;
                    }
                }
            }
        }

        function updateNestedPropertyEnum(toolIndex, parentPropName, nestedPropName, enumString) {
            const tool = tools[toolIndex];
            const toolName = tool.name;
            const enumValues = enumString.split(',').map(v => v.trim()).filter(v => v);

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                if (internalArg.original_schema?.properties?.[nestedPropName]) {
                    if (enumValues.length > 0) {
                        internalArg.original_schema.properties[nestedPropName].enum = enumValues;
                    } else {
                        delete internalArg.original_schema.properties[nestedPropName].enum;
                    }
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    if (enumValues.length > 0) {
                        parentProp.properties[nestedPropName].enum = enumValues;
                    } else {
                        delete parentProp.properties[nestedPropName].enum;
                    }
                }
            }
        }

        function toggleNestedEnum(toolIndex, parentPropName, nestedPropName, hasEnum) {
            const tool = tools[toolIndex];
            const toolName = tool.name;

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                if (internalArg.original_schema?.properties?.[nestedPropName]) {
                    if (hasEnum) {
                        internalArg.original_schema.properties[nestedPropName].enum = [];
                    } else {
                        delete internalArg.original_schema.properties[nestedPropName].enum;
                    }
                    renderToolEditor(tool, toolIndex);
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    if (hasEnum) {
                        parentProp.properties[nestedPropName].enum = [];
                    } else {
                        delete parentProp.properties[nestedPropName].enum;
                    }
                    renderToolEditor(tool, toolIndex);
                }
            }
        }

        function updateNestedPropertyItems(toolIndex, parentPropName, nestedPropName, itemType) {
            const tool = tools[toolIndex];
            const toolName = tool.name;

            // Check if this is an internal property
            const isInternal = !tool.inputSchema.properties[parentPropName] &&
                               internalArgs[toolName]?.[parentPropName];

            if (isInternal) {
                // Update original_schema.properties in internalArgs
                const internalArg = internalArgs[toolName][parentPropName];
                if (internalArg.original_schema?.properties?.[nestedPropName]) {
                    internalArg.original_schema.properties[nestedPropName].items = { type: itemType };
                }
            } else {
                // Normal signature property - update inputSchema
                const parentProp = tool.inputSchema.properties[parentPropName];
                if (parentProp && parentProp.properties && parentProp.properties[nestedPropName]) {
                    parentProp.properties[nestedPropName].items = { type: itemType };
                }
            }
        }

        function addNewTool() {
            const newTool = {
                name: 'new_tool_' + Date.now(),
                description: 'New tool description',
                mcp_service: '',  // Add mcp_service field
                inputSchema: {
                    type: 'object',
                    properties: {},
                    required: []
                }
            };
            tools.push(newTool);
            renderToolList();
            selectTool(tools.length - 1);
        }

        function deleteTool(index) {
            if (confirm(`Delete tool "${tools[index].name}"?`)) {
                const profileQuery = profileParam();
                fetch(`/api/tools/${index}${profileQuery}`, {
                    method: 'DELETE'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification(data.message + (data.backup ? ` (Backup: ${data.backup})` : ''), 'success');
                        tools.splice(index, 1);
                        currentToolIndex = -1;
                        renderToolList();
                        document.getElementById('editorContent').innerHTML = `
                            <div style="text-align: center; padding: 50px; color: var(--text-secondary);">
                                Select a tool from the left sidebar to edit
                            </div>
                        `;
                    } else {
                        showNotification(`Error deleting tool: ${data.error}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error deleting tool:', error);
                    showNotification('Failed to delete tool', 'error');
                });
            }
        }

        function saveTools() {
            console.log('[DEBUG] saveTools() called');
            console.log('[DEBUG] tools:', tools);
            console.log('[DEBUG] internalArgs:', internalArgs);
            console.log('[DEBUG] fileMtimes:', fileMtimes);

            const profileQuery = profileParam();
            const saveProfile = originalProfile || 'default';
            const saveButton = document.querySelector('[data-debug-id="BTN_SAVE"]');
            const saveLabel = saveButton ? saveButton.innerHTML : '';
            console.log('[DEBUG] profileQuery:', profileQuery);
            console.log('[DEBUG] saveProfile:', saveProfile);

            // Use the new save-all API to atomically save tools + internal_args
            const url = `/api/tools/save-all${profileQuery}`;
            const payload = {
                tools: tools,
                internal_args: internalArgs,
                file_mtimes: fileMtimes  // For conflict detection
            };

            console.log('[DEBUG] Request URL:', url);
            try {
                console.log('[DEBUG] Request payload:', JSON.stringify(payload, null, 2));
            } catch (error) {
                console.warn('[DEBUG] Request payload serialization failed:', error);
            }

            let payloadJson = '';
            try {
                payloadJson = JSON.stringify(payload);
            } catch (error) {
                console.error('Error serializing save payload:', error);
                showNotification(`Failed to serialize tools: ${error.message}`, 'error');
                return;
            }

            if (saveButton) {
                saveButton.disabled = true;
                saveButton.innerHTML = '<span class="material-icons">save</span> Saving...';
            }

            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: payloadJson
            })
            .then(response => {
                console.log('[DEBUG] Response status:', response.status);
                console.log('[DEBUG] Response headers:', response.headers);

                if (response.status === 409) {
                    // Conflict detected
                    return response.json().then(data => {
                        console.log('[DEBUG] Conflict data:', data);
                        showNotification(`${data.message}. Please reload and try again.`, 'error');
                        throw new Error('Conflict');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('[DEBUG] Response data:', data);

                if (data.success) {
                    const savedInfo = Array.isArray(data.saved) ? data.saved.join(', ') : 'files';
                    showNotification(`Saved: ${savedInfo} to "${saveProfile}"!`, 'success');
                    // Update file mtimes after successful save
                    loadTools();  // Reload to get fresh mtimes
                } else {
                    showNotification(`Error saving: ${data.error || 'Unknown error'}`, 'error');
                }
            })
            .catch(error => {
                console.error('[DEBUG] Catch block error:', error);
                if (error.message !== 'Conflict') {
                    console.error('Error saving:', error);
                    showNotification('Failed to save', 'error');
                }
            })
            .finally(() => {
                if (saveButton) {
                    saveButton.disabled = false;
                    saveButton.innerHTML = saveLabel || '<span class="material-icons">save</span>';
                }
            });
        }

        function validateTools() {
            const profileQuery = profileParam();
            fetch(`/api/tools/validate${profileQuery}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(tools)
            })
            .then(response => response.json())
            .then(data => {
                if (data.valid) {
                    showNotification('Tools are valid!', 'success');
                } else {
                    showNotification(`Validation error: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error validating tools:', error);
                showNotification('Failed to validate tools', 'error');
            });
        }

        function showBackups() {
            const profileQuery = profileParam();
            fetch(`/api/backups${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    const backupList = document.getElementById('backupList');
                    if (data.length === 0) {
                        backupList.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No backups available</p>';
                    } else {
                        backupList.innerHTML = data.map(backup => `
                            <div class="backup-item">
                                <div class="backup-info">
                                    <div class="backup-name">${backup.filename}</div>
                                    <div class="backup-date">${new Date(backup.modified).toLocaleString()}</div>
                                </div>
                                <div>
                                    <button class="btn btn-secondary btn-sm" onclick="viewBackup('${backup.filename}')">View</button>
                                    <button class="btn btn-primary btn-sm" onclick="restoreBackup('${backup.filename}')">Restore</button>
                                </div>
                            </div>
                        `).join('');
                    }
                    document.getElementById('backupModal').classList.add('show');
                })
                .catch(error => {
                    console.error('Error loading backups:', error);
                    showNotification('Failed to load backups', 'error');
                });
        }

        function viewBackup(filename) {
            const profileQuery = profileParam();
            fetch(`/api/backups/${filename}${profileQuery}`)
                .then(response => response.json())
                .then(data => {
                    alert(JSON.stringify(data, null, 2));
                })
                .catch(error => {
                    console.error('Error viewing backup:', error);
                    showNotification('Failed to view backup', 'error');
                });
        }

        function restoreBackup(filename) {
            if (confirm(`Restore backup from ${filename}? Current state will be backed up first.`)) {
                const profileQuery = profileParam();
                fetch(`/api/backups/${filename}/restore${profileQuery}`, {
                    method: 'POST'
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showNotification(`Backup restored successfully! Current state backed up as: ${data.current_backup}`, 'success');
                        closeModal('backupModal');
                        loadTools();
                    } else {
                        showNotification(`Error restoring backup: ${data.error}`, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error restoring backup:', error);
                    showNotification('Failed to restore backup', 'error');
                });
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                if (modalId === 'propertyModal') {
                    modal.parentElement.remove();
                } else {
                    modal.classList.remove('show');
                }
            }
        }

        function showNotification(message, type) {
            console.log('[DEBUG] showNotification() called');
            console.log('[DEBUG] message:', message);
            console.log('[DEBUG] type:', type);

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            console.log('[DEBUG] Notification element created and appended');
            console.log('[DEBUG] notification.className:', notification.className);
            console.log('[DEBUG] notification.textContent:', notification.textContent);

            setTimeout(() => {
                notification.remove();
                console.log('[DEBUG] Notification removed after 3 seconds');
            }, 3000);
        }

        function togglePropertyCollapse(propId) {
            const content = document.getElementById(`content-${propId}`);
            const icon = document.getElementById(`icon-${propId}`);
            const header = document.getElementById(`header-${propId}`);

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = 'â–¼';
                header.classList.add('expanded');
            } else {
                content.classList.add('collapsed');
                icon.classList.add('collapsed');
                icon.textContent = 'â–¶';
                header.classList.remove('expanded');
            }
        }

        function toggleNestedPropCollapse(nestedPropId) {
            const content = document.getElementById(`nested-content-${nestedPropId}`);
            const icon = document.getElementById(`nested-icon-${nestedPropId}`);

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        function toggleJsonView() {
            const viewer = document.getElementById('json-viewer');
            const icon = document.getElementById('json-collapse-icon');

            if (viewer.classList.contains('collapsed')) {
                viewer.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = 'â–¼';
            } else {
                viewer.classList.add('collapsed');
                icon.classList.add('collapsed');
                icon.textContent = 'â–¶';
            }
        }

        function expandAllProperties() {
            const allProperties = document.querySelectorAll('.property-collapse-content');
            const allIcons = document.querySelectorAll('.property-collapse-header .collapse-icon');
            const allHeaders = document.querySelectorAll('.property-collapse-header');

            allProperties.forEach(prop => prop.classList.remove('collapsed'));
            allIcons.forEach(icon => { icon.classList.remove('collapsed'); icon.textContent = 'â–¼'; });
            allHeaders.forEach(header => header.classList.add('expanded'));
        }

        function collapseAllProperties() {
            const allProperties = document.querySelectorAll('.property-collapse-content');
            const allIcons = document.querySelectorAll('.property-collapse-header .collapse-icon');
            const allHeaders = document.querySelectorAll('.property-collapse-header');

            allProperties.forEach(prop => prop.classList.add('collapsed'));
            allIcons.forEach(icon => { icon.classList.add('collapsed'); icon.textContent = 'â–¶'; });
            allHeaders.forEach(header => header.classList.remove('expanded'));
        }

        function initDebugIndexing() {
            ensureDebugOverlay();
            const saved = localStorage.getItem('mcp_debug_indexes') === '1';
            setDebugIndexState(saved);

            document.addEventListener('scroll', queueDebugIndexRefresh, true);
            window.addEventListener('resize', queueDebugIndexRefresh);
            document.addEventListener('mousemove', updateDebugTooltip);
        }

        function toggleDebugIndexes() {
            setDebugIndexState(!debugIndexEnabled);
        }

        function setDebugIndexState(enabled) {
            debugIndexEnabled = enabled;
            document.body.classList.toggle('debug-indexes', enabled);
            localStorage.setItem('mcp_debug_indexes', enabled ? '1' : '0');

            const toggle = document.getElementById('debugIndexToggle');
            if (toggle) {
                toggle.classList.toggle('btn-debug-active', enabled);
                toggle.setAttribute('aria-pressed', enabled ? 'true' : 'false');
            }

            if (enabled) {
                queueDebugIndexRefresh();
            } else {
                const overlay = document.getElementById('debug-overlay');
                if (overlay) {
                    overlay.innerHTML = '';
                }
                hideDebugTooltip();
                updateDebugDuplicateBadge(0);
            }
        }

        function ensureDebugOverlay() {
            let overlay = document.getElementById('debug-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'debug-overlay';
                document.body.appendChild(overlay);
            }

            let tooltip = document.getElementById('debug-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'debug-tooltip';
                document.body.appendChild(tooltip);
            }

            if (!debugIndexObserver) {
                debugIndexObserver = new MutationObserver(() => {
                    debugMetadataDirty = true;
                    queueDebugIndexRefresh();
                });
                debugIndexObserver.observe(document.body, { childList: true, subtree: true });
            }

            return overlay;
        }

        function queueDebugIndexRefresh() {
            if (!debugIndexEnabled || debugIndexRefreshPending) {
                return;
            }

            debugIndexRefreshPending = true;
            requestAnimationFrame(() => {
                debugIndexRefreshPending = false;
                refreshDebugIndexes();
            });
        }

        function refreshDebugIndexes() {
            if (!debugIndexEnabled) {
                return;
            }

            const overlay = ensureDebugOverlay();
            overlay.innerHTML = '';

            const targets = getDebugTargets();
            const usedIds = new Set();
            const idCounts = new Map();
            const buttonCounter = { value: 1 };
            const fieldCounter = { value: 1 };

            targets.areas.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('a', usedIds, { value: 1 });
                registerDebugId(labelText, usedIds, idCounts, target);
                addDebugLabel(overlay, target, labelText, 'area', isAuto);
            });

            targets.buttons.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('', usedIds, buttonCounter);
                registerDebugId(labelText, usedIds, idCounts, target);
                addDebugLabel(overlay, target, labelText, 'button', isAuto);
            });

            targets.fields.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('f', usedIds, fieldCounter);
                registerDebugId(labelText, usedIds, idCounts, target);
                addDebugLabel(overlay, target, labelText, 'field', isAuto);
            });

            const duplicateCount = Array.from(idCounts.values()).filter(count => count > 1).length;
            updateDebugDuplicateBadge(duplicateCount);
            debugMetadataDirty = false;
        }

        function ensureDebugMetadata() {
            if (!debugMetadataDirty) {
                return;
            }

            const targets = getDebugTargets();
            const usedIds = new Set();
            const buttonCounter = { value: 1 };
            const fieldCounter = { value: 1 };

            targets.areas.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('a', usedIds, { value: 1 });
                usedIds.add(labelText);
                applyDebugMetadata(target, labelText, isAuto);
            });

            targets.buttons.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('', usedIds, buttonCounter);
                usedIds.add(labelText);
                applyDebugMetadata(target, labelText, isAuto);
            });

            targets.fields.forEach(target => {
                const explicitId = getExplicitDebugId(target);
                const isAuto = !explicitId;
                const labelText = explicitId || getNextAutoDebugId('f', usedIds, fieldCounter);
                usedIds.add(labelText);
                applyDebugMetadata(target, labelText, isAuto);
            });

            debugMetadataDirty = false;
        }

        function getDebugTargets() {
            const buttons = Array.from(document.querySelectorAll('button')).filter(isValidDebugTarget);
            const fields = Array.from(document.querySelectorAll('input, textarea, select'))
                .filter(isTextLikeInput)
                .filter(isValidDebugTarget);
            const areas = [];
            const manualTargets = Array.from(document.querySelectorAll('[data-debug-id]')).filter(isValidDebugTarget);
            const buttonSet = new Set(buttons);
            const fieldSet = new Set(fields);

            manualTargets.forEach(target => {
                if (buttonSet.has(target) || fieldSet.has(target)) {
                    return;
                }

                const debugId = target.getAttribute('data-debug-id');
                if (debugId && debugId.startsWith('AREA_')) {
                    areas.push(target);
                    return;
                }

                const tag = target.tagName;
                if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') {
                    fields.push(target);
                    fieldSet.add(target);
                } else {
                    buttons.push(target);
                    buttonSet.add(target);
                }
            });

            return { buttons, fields, areas };
        }

        function getExplicitDebugId(target) {
            const manualId = target.getAttribute('data-debug-id');
            if (manualId && manualId.trim() && target.getAttribute('data-debug-auto') !== '1') {
                return manualId.trim();
            }

            const legacyId = target.getAttribute('data-fixed-debug-id');
            if (legacyId && legacyId.trim()) {
                return legacyId.trim();
            }

            return null;
        }

        function registerDebugId(labelText, usedIds, idCounts, target) {
            if (usedIds.has(labelText)) {
                console.warn(`[DebugIndex] Duplicate data-debug-id "${labelText}"`, target);
            }
            usedIds.add(labelText);
            idCounts.set(labelText, (idCounts.get(labelText) || 0) + 1);
        }

        function updateDebugDuplicateBadge(duplicateCount) {
            const badge = document.getElementById('debugDuplicateBadge');
            if (!badge) {
                return;
            }

            if (duplicateCount > 0) {
                badge.textContent = String(duplicateCount);
                badge.classList.add('visible');
                badge.setAttribute('aria-label', `Duplicate debug IDs: ${duplicateCount}`);
            } else {
                badge.textContent = '';
                badge.classList.remove('visible');
                badge.removeAttribute('aria-label');
            }
        }

        function getNextAutoDebugId(prefix, usedIds, counterRef) {
            let candidate = '';
            do {
                candidate = `${prefix}${counterRef.value}`;
                counterRef.value += 1;
            } while (usedIds.has(candidate));
            return candidate;
        }

        function isTextLikeInput(el) {
            if (!el || !el.tagName) {
                return false;
            }

            if (el.tagName === 'TEXTAREA' || el.tagName === 'SELECT') {
                return true;
            }

            if (el.tagName !== 'INPUT') {
                return false;
            }

            const type = (el.getAttribute('type') || 'text').toLowerCase();
            return !['checkbox', 'radio', 'button', 'submit', 'reset', 'hidden', 'image', 'file', 'range', 'color'].includes(type);
        }

        function isValidDebugTarget(el) {
            if (!el || !(el instanceof Element)) {
                return false;
            }

            if (el.closest('#debug-overlay') || el.closest('#debug-tooltip')) {
                return false;
            }

            if (el.hasAttribute('data-debug-skip') || el.closest('[data-debug-skip="true"]')) {
                return false;
            }

            return true;
        }

        function applyDebugMetadata(target, labelText, isAuto) {
            if (!target || !labelText) {
                return;
            }

            if (isAuto) {
                target.setAttribute('data-debug-auto', '1');
                target.setAttribute('data-debug-auto-id', labelText);
                target.removeAttribute('data-debug-id');
            } else {
                target.removeAttribute('data-debug-auto');
                target.removeAttribute('data-debug-auto-id');
                target.setAttribute('data-debug-id', labelText);
            }

            const actions = getDebugActions(target);
            if (actions.length > 0) {
                target.setAttribute('data-debug-actions', actions.join('\n'));
            } else {
                target.removeAttribute('data-debug-actions');
            }
        }

        function addDebugLabel(overlay, target, labelText, kind, isAuto) {
            if (!target || !labelText) {
                return;
            }

            applyDebugMetadata(target, labelText, isAuto);

            const rect = target.getBoundingClientRect();
            if (!isRectVisible(rect)) {
                return;
            }

            const label = document.createElement('div');
            label.className = `debug-id-label ${kind}`;
            label.textContent = labelText;
            overlay.appendChild(label);
            positionDebugLabel(label, rect);
        }

        function getDebugActions(target) {
            const attributes = [
                'onclick',
                'onchange',
                'oninput',
                'onkeyup',
                'onkeydown',
                'onfocus',
                'onblur',
                'onmouseenter',
                'onmouseleave',
                'onmouseover',
                'onmouseout'
            ];

            const actions = [];
            attributes.forEach(attr => {
                const value = target.getAttribute(attr);
                if (value) {
                    actions.push(`${attr}: ${value.trim().replace(/\s+/g, ' ')}`);
                }
            });

            return actions;
        }

        function isRectVisible(rect) {
            if (!rect) {
                return false;
            }

            if (rect.width < 1 && rect.height < 1) {
                return false;
            }

            return !(rect.bottom < 0 || rect.right < 0 || rect.top > window.innerHeight || rect.left > window.innerWidth);
        }

        function positionDebugLabel(label, rect) {
            const offset = 4;
            let left = rect.left + offset;
            let top = rect.top + offset;

            label.style.left = `${left}px`;
            label.style.top = `${top}px`;

            const labelRect = label.getBoundingClientRect();
            if (labelRect.right > window.innerWidth - 4) {
                left = window.innerWidth - labelRect.width - 4;
            }
            if (labelRect.bottom > window.innerHeight - 4) {
                top = window.innerHeight - labelRect.height - 4;
            }

            label.style.left = `${Math.max(4, left)}px`;
            label.style.top = `${Math.max(4, top)}px`;
        }

        function updateDebugTooltip(event) {
            if (!debugIndexEnabled) {
                ensureDebugMetadata();
            }

            const target = event.target instanceof Element
                ? event.target.closest('[data-debug-id], [data-debug-auto-id], [data-fixed-debug-id]')
                : null;
            if (!target || !isValidDebugTarget(target)) {
                hideDebugTooltip();
                return;
            }

            const debugId = getExplicitDebugId(target) || target.getAttribute('data-debug-auto-id');
            if (!debugId) {
                hideDebugTooltip();
                return;
            }

            const actions = target.getAttribute('data-debug-actions');
            const tooltip = document.getElementById('debug-tooltip');
            if (!tooltip) {
                return;
            }

            tooltip.textContent = actions ? `ID: ${debugId}\n${actions}` : `ID: ${debugId}`;
            tooltip.style.display = 'block';

            let left = event.clientX + 12;
            let top = event.clientY + 12;

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;

            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth - 8) {
                left = window.innerWidth - rect.width - 8;
            }
            if (rect.bottom > window.innerHeight - 8) {
                top = window.innerHeight - rect.height - 8;
            }

            tooltip.style.left = `${Math.max(8, left)}px`;
            tooltip.style.top = `${Math.max(8, top)}px`;
        }

        function hideDebugTooltip() {
            const tooltip = document.getElementById('debug-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
                tooltip.textContent = '';
            }
        }
    </script>
</body>
</html>
