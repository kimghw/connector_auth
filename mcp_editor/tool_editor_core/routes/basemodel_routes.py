"""
BaseModel Routes

BaseModel 스키마 API 엔드포인트:
- GET /api/basemodels
- GET /api/graph-types-properties
- POST /api/tools/<int>/apply-basemodel

Note: types_property_{server}.json is auto-generated by mcp_service_scanner
      during web editor startup (scan_all_registries).
"""

import os
import json
from flask import request, jsonify

from . import basemodel_bp
from ..config import (
    BASE_DIR,
    get_profile_config,
    resolve_paths,
)
from ..tool_loader import load_tool_definitions
from ..tool_saver import save_tool_definitions
from tool_editor_web_server_mappings import get_server_name_from_profile
from pydantic_to_schema import (
    generate_mcp_schemas_from_graph_types,
    update_tool_with_basemodel_schema,
    load_graph_types_models,
)


@basemodel_bp.route("/api/graph-types-properties", methods=["GET"])
def get_graph_types_properties():
    """Get available properties from types_property_{server}.json.

    The types_property file is auto-generated by mcp_service_scanner during
    web editor startup. It contains referenced type definitions extracted
    from service function parameters.
    """
    try:
        profile = request.args.get("profile")
        profile_conf = get_profile_config(profile)
        paths = resolve_paths(profile_conf)

        # Get server name for file lookup
        server_name = get_server_name_from_profile(profile) or "types"
        types_file_name = (
            server_name.replace("mcp_", "") if server_name and server_name.startswith("mcp_") else server_name
        )

        # Primary path: mcp_{server}/types_property_{server}.json
        types_property_path = os.path.join(
            BASE_DIR, f"mcp_{types_file_name}", f"types_property_{types_file_name}.json"
        )

        if os.path.exists(types_property_path):
            with open(types_property_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                data["has_types"] = True
                data["types_name"] = f"{types_file_name}_types"
                return jsonify(data)

        # No types_property file found - return empty response
        # This is normal if no object-type parameters were found in service functions
        return jsonify({
            "classes": [],
            "properties_by_class": {},
            "all_properties": [],
            "has_types": False,
            "types_name": None,
        })

    except Exception as e:
        return jsonify({
            "error": str(e),
            "classes": [],
            "properties_by_class": {},
            "all_properties": [],
            "has_types": False
        }), 500


@basemodel_bp.route("/api/basemodels", methods=["GET"])
def get_basemodels():
    """Get available BaseModel schemas from outlook_types.py"""
    try:
        profile = request.args.get("profile")
        profile_conf = get_profile_config(profile)
        paths = resolve_paths(profile_conf)
        graph_type_paths = paths.get("types_files")

        models = load_graph_types_models(graph_type_paths)
        schemas = generate_mcp_schemas_from_graph_types(graph_type_paths)

        result = []
        for name, model in models.items():
            schema = schemas.get(name, {})
            result.append({"name": name, "description": model.__doc__ or f"{name} BaseModel", "schema": schema})

        return jsonify(result)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@basemodel_bp.route("/api/tools/<int:tool_index>/apply-basemodel", methods=["POST"])
def apply_basemodel_to_property(tool_index):
    """Apply a BaseModel schema to a specific property of a tool"""
    try:
        profile = request.args.get("profile")
        profile_conf = get_profile_config(profile)
        paths = resolve_paths(profile_conf)
        graph_type_paths = paths.get("types_files")

        data = request.json
        property_name = data.get("property_name")
        basemodel_name = data.get("basemodel_name")

        if not property_name or not basemodel_name:
            return jsonify({"error": "Missing property_name or basemodel_name"}), 400

        # Load current tools
        tools = load_tool_definitions(paths)
        if isinstance(tools, dict) and "error" in tools:
            return jsonify(tools), 500

        if tool_index >= len(tools):
            return jsonify({"error": "Invalid tool index"}), 400

        # Apply BaseModel schema
        tool = tools[tool_index]
        updated_tool = update_tool_with_basemodel_schema(tool, basemodel_name, property_name, graph_type_paths)

        # Save the updated tools
        force_rescan = str(request.args.get("force_rescan", "")).lower() in ("1", "true", "yes")
        result = save_tool_definitions(tools, paths, force_rescan=force_rescan)
        if "error" in result:
            return jsonify(result), 500

        return jsonify({"success": True, "tool": updated_tool})
    except Exception as e:
        return jsonify({"error": str(e)}), 500
