
classDiagram
    %% Data Models
    class Document {
        +id: str
        +filename: str
        +file_path: str
        +file_size: int
        +upload_time: datetime
        +status: DocumentStatus
        +chunk_count: int
        +error_message: str?
        +to_dict() dict
    }

    class Chunk {
        +id: str
        +document_id: str
        +chunk_index: int
        +content: str
        +token_count: int
        +char_start: int
        +char_end: int
        +embedding_id: str?
        +to_dict() dict
    }

    class SearchResult {
        +chunk_id: str
        +document_id: str
        +document_name: str
        +content: str
        +similarity_score: float
        +chunk_index: int
        +to_dict() dict
    }

    class ProcessStatus {
        +doc_id: str
        +status: DocumentStatus
        +current_step: ProcessingStep
        +progress: int
        +error_message: str?
        +started_at: datetime
        +updated_at: datetime
        +to_dict() dict
    }

    %% Enums
    class DocumentStatus {
        <<enumeration>>
        PENDING
        PROCESSING
        COMPLETED
        ERROR
        DELETED
    }

    class ProcessingStep {
        <<enumeration>>
        UPLOAD
        EXTRACTION
        CHUNKING
        EMBEDDING
        INDEXING
        COMPLETED
    }

    %% Protocols (Interfaces)
    class IDocumentManager {
        <<interface>>
        +upload(file_path) str
        +list_all(status?) List~Document~
        +get_by_id(doc_id) Document
        +delete(doc_id) bool
    }

    class ITextProcessor {
        <<interface>>
        +extract_text(file_path) str
        +clean_text(text) str
        +normalize_text(text) str
    }

    class IChunker {
        <<interface>>
        +create_chunks(text, max_tokens, overlap) List~Dict~
        +count_tokens(text) int
    }

    class IEmbeddingGenerator {
        <<interface>>
        +generate_embedding(text) ndarray
        +generate_embeddings_batch(texts) List~ndarray~
        +dimension: int
    }

    class ISearchEngine {
        <<interface>>
        +search(query, top_k) List~SearchResult~
        +search_with_filter(query, filters) List~SearchResult~
    }

    class IVectorStore {
        <<interface>>
        +add_vector(chunk_id, vector) bool
        +search_vectors(query_vector, top_k) List~tuple~
        +delete_vector(chunk_id) bool
        +get_vector(chunk_id) ndarray?
        +rebuild_index() bool
    }

    %% Relationships
    Document "1" --> "*" Chunk : contains
    Chunk "1" --> "1" SearchResult : found in
    Document ..> DocumentStatus : uses
    ProcessStatus ..> DocumentStatus : uses
    ProcessStatus ..> ProcessingStep : uses

    IDocumentManager ..> Document : manages
    IChunker ..> Chunk : creates
    ISearchEngine ..> SearchResult : returns
    IVectorStore ..> ISearchEngine : used by
    IEmbeddingGenerator ..> IVectorStore : feeds
    