---
description: 범용 리팩토링 가이드 - 기능 보존 및 안전성 체크리스트 (project)
---

> **공통 지침**: 작업 전 [common.md](common.md) 참조

# 리팩토링 사전 준비 및 결과 확인 지침

> 범용 리팩토링 가이드 - 기능 보존 및 안전성 체크리스트

---

## 핵심 원칙

### 기본 원칙
- **Golden Rule**: 내부 구조를 개선하되, 외부 동작/출력/UI는 동일
- **작게 변경, 바로 검증**: 한 번에 하나씩 적용하고 즉시 확인
- **기준선 우선**: 비교 가능한 기준을 먼저 확보
- **계약 보존**: 함수의 Input/Output 시그니처와 동작 계약은 불변

### Martin Fowler의 리팩토링 원칙
1. **Two Hats (두 개의 모자)**
   - 기능 추가 모자 vs 리팩토링 모자
   - 한 번에 하나만 착용 (기능 추가와 리팩토링을 동시에 하지 않음)

2. **Small Steps (작은 단계)**
   - 작은 변경 → 테스트 → 커밋의 반복
   - 언제든 롤백 가능한 상태 유지

3. **Test First (테스트 우선)**
   - 리팩토링 전에 테스트가 있어야 함
   - 테스트가 안전망 역할

### Kent Beck의 3단계 규칙
1. **Make it work** - 일단 동작하게
2. **Make it right** - 올바르게 리팩토링
3. **Make it fast** - 필요시 최적화

### Boy Scout Rule
> "Leave the code better than you found it" (코드를 처음보다 깨끗하게)
- 코드를 건드릴 때마다 조금씩 개선

### TDD의 Red-Green-Refactor 사이클
1. **Red**: 실패하는 테스트 작성
2. **Green**: 테스트 통과하는 최소 코드 작성
3. **Refactor**: 코드 정리 (테스트는 계속 통과)

---

## 수정 방식 규칙 (Modification Rules)

### ❌ 금지 사항
- 파일 전체를 삭제 후 새로 작성
- 함수/컴포넌트 전체를 지우고 새 구현으로 교체
- 한 번에 여러 함수/컴포넌트 동시 수정
- 기존 코드를 읽고 "더 나은 버전"으로 전체 재작성
- 동작 확인 없이 연속적인 대규모 변경

### ✅ 권장 방식
- 기존 코드를 **줄 단위/블록 단위로 수정**
- Extract → 이동 → Inline 순서로 점진적 변경
- 기존 함수는 유지하고, 새 함수 추가 후 점진적 마이그레이션
- 변경 후 즉시 동작 확인 (테스트 또는 수동)
- 의심스러우면 기존 코드 유지

### 변경 크기 가이드
| 변경 규모 | 허용 여부 | 조건 |
|----------|----------|------|
| 1-10줄 수정 | ✅ 허용 | 즉시 테스트 |
| 11-50줄 수정 | ⚠️ 주의 | 단계별 분리 권장 |
| 50줄+ 또는 함수 전체 | ❌ 금지 | 반드시 단계 분리 |

---

## 리팩토링 계획 수립

### 변경 범위 명확화
1. **변경 대상 (Target)**
   - 개선할 함수/클래스/컴포넌트 목록
   - 변경 목적과 예상 결과 명시
   - 허용되는 시그니처 변경 범위

2. **변경 금지 대상 (Preserve)**
   - 변경하지 않을 함수/클래스 목록
   - Public API와 외부 인터페이스
   - 의존성이 높은 핵심 모듈

3. **영향 범위 (Impact)**
   - 변경 대상의 호출부 목록
   - 필요한 마이그레이션 작업
   - 테스트 수정 필요 여부

### 변경 전략 결정
```
## 리팩토링 계획서
### 목적: [리팩토링 목적]
### 날짜: YYYY-MM-DD

### 변경 대상 함수
| 함수명 | 현재 시그니처 | 변경 후 시그니처 | 변경 이유 | 영향 범위 |
|--------|---------------|------------------|-----------|-----------|
| func1  | (a: string)   | (a: string, b?: number) | 기능 확장 | 3개 파일 |

### 보존 대상 (변경 금지)
- [ ] core/auth.ts - 인증 모듈
- [ ] api/endpoints.ts - 외부 API
- [ ] utils/helpers.ts - 공통 유틸

### 마이그레이션 계획
1. 새 시그니처로 함수 업데이트
2. 기존 호출부를 새 시그니처에 맞게 수정
3. Deprecated 표시 후 단계적 제거
```

---

## 계약 보존 원칙 (Contract Preservation)

### 변경 대상이 아닌 경우 - 완전 보존
1. **함수 시그니처 유지**
   - 함수명, 매개변수(타입, 순서, 기본값), 반환 타입 변경 금지
   - 오버로드 시그니처 유지

2. **Public API 보존**
   - export된 함수/클래스/컴포넌트의 인터페이스 유지
   - 기존 호출부가 수정 없이 동작해야 함

3. **동작 계약 유지**
   - 같은 입력 → 같은 출력 (순수 함수의 경우)
   - 사이드 이펙트의 종류와 시점 동일
   - 에러/예외 발생 조건과 타입 동일

### 변경 대상인 경우 - 계획된 변경
1. **의도적 시그니처 변경**
   - 계획서에 명시된 범위 내에서만 변경
   - 호출부 마이그레이션 계획 필수
   - Breaking Change 문서화

2. **점진적 마이그레이션**
   - 가능하면 하위 호환성 유지 (옵셔널 매개변수 활용)
   - Deprecated 플래그로 단계적 전환
   - 버전 관리 고려

3. **테스트 업데이트**
   - 변경된 시그니처에 맞는 테스트 수정
   - 기존 동작과 새 동작 모두 테스트
   - 마이그레이션 기간 동안 양쪽 지원

### 리팩토링 전 필수 기록 항목

```
## 대상: [함수명/컴포넌트명]
## 파일: [파일 경로]
## 변경 구분: [ ] 변경 대상 / [ ] 보존 대상

### 현재 시그니처
- 함수명:
- 매개변수: (name: type, ...)
- 반환값: type

### 계획된 변경 (변경 대상인 경우만)
- 새 시그니처:
- 변경 이유:
- 마이그레이션 방법:

### Props/State (컴포넌트인 경우)
- props: { prop1: type, prop2: type }
- state: { state1: type }

### 사이드 이펙트
- API 호출: [method] [endpoint]
- 상태 변경: [변경하는 상태 목록]
- DOM 조작: [있다면 기술]
- 이벤트 발생: [발생시키는 이벤트]

### 의존성 (이 함수가 사용하는 것)
- [모듈 경로] → [함수/클래스명]

### 역의존성 (이 함수를 사용하는 곳)
- [파일:라인] - [사용 맥락]
- 영향도: [High/Medium/Low]
```

---

## 사전 준비 (리팩토링 전)

### 1. 범위와 불변 조건 확정
- 변경 대상/비대상 명시 (파일, 모듈, 화면, API)
- **불변 조건** 정의: 동작, UI, 응답 포맷, 성능 허용 범위
- 위험도가 높은 기능/화면 리스트업
- **변경 대상 함수/컴포넌트의 계약 기록** (위 템플릿 사용)

### 2. 기준선(Baseline) 수집

#### 코드 기준선
- 변경 대상 함수/컴포넌트 목록과 시그니처
- 각 함수의 Input/Output 예시 (테스트 케이스)
- export되는 Public API 목록

#### 테스트 기준선
- 자동 테스트 결과 저장
- 핵심 사용자 시나리오 목록과 결과 기록

#### UI 기준선
- 주요 화면 스크린샷
- DOM 스냅샷 (컴포넌트 구조)
- 디자인 체크포인트 (레이아웃, 간격, 색상)

#### API 기준선
- 핵심 엔드포인트 샘플 요청/응답 저장
- 응답 스키마 (필드명, 타입, 필수 여부)

#### 성능 기준선
- 핵심 플로우의 처리/응답 시간 수치 기록

### 3. 롤백 준비
- 새 브랜치/태그 생성
- 복구 절차 간단 문서화 (되돌릴 커밋/태그, 재배포 방법)

---

## 리팩토링 중 점검

### 변경 프로세스
1. **단일 변경 적용**: 한 번에 하나의 함수/컴포넌트만 수정
2. **즉시 검증**: 변경 직후 테스트 실행
3. **계약 확인**: Input/Output이 기존과 동일한지 확인
4. **기록**: 영향 받은 화면/API/로직 기록
5. **커밋**: 검증 완료 후 작은 단위로 커밋

### 변경 중 체크리스트
- [ ] 함수 시그니처가 변경되지 않았는가?
- [ ] 반환값의 타입과 구조가 동일한가?
- [ ] 사이드 이펙트가 동일하게 발생하는가?
- [ ] 기존 호출부가 수정 없이 동작하는가?
- [ ] 에러 처리 로직이 동일한가?

---

## UI 컴포넌트 리팩토링 규칙

### 구조 보존
- [ ] 기존 DOM 구조(태그 중첩, 순서) 유지
- [ ] className/id 유지 (CSS 셀렉터 의존성)
- [ ] data-* 속성 유지 (테스트/트래킹 의존성)
- [ ] aria-* 속성 유지 (접근성)
- [ ] key 속성 유지 (리스트 렌더링)

### 동작 보존
- [ ] 이벤트 핸들러(onClick, onChange 등) 동일 동작
- [ ] 조건부 렌더링 로직 동일
- [ ] 렌더링 순서 동일
- [ ] 폼 제출/유효성 검사 로직 동일

### 스타일 보존
- [ ] 인라인 스타일 유지 또는 동등 대체
- [ ] CSS 클래스 적용 순서 유지
- [ ] 애니메이션/트랜지션 유지
- [ ] 반응형 브레이크포인트 동작 유지

### Props 보존
- [ ] 필수 props 목록 동일
- [ ] props 기본값 동일
- [ ] props 타입 동일
- [ ] children 처리 방식 동일

---

## 결과 확인 (리팩토링 후)

### 1. 계약 검증
- 변경된 함수/컴포넌트의 시그니처가 기록과 동일한지 확인
- 기존 호출부 코드 변경 없이 동작하는지 확인
- Input/Output 예시로 동작 동일성 확인

### 2. 회귀 검증
- 전체/핵심 테스트 재실행
- 기준선과 비교해 기능 동일성 확인

### 3. UI/출력 비교
- 스크린샷/DOM 스냅샷 비교
- API 응답 구조/필드/값 비교
- 로그/에러/경고 증가 여부 확인

### 4. 성능/리소스 확인
- 기준선 대비 큰 변화 없음 (예: ±10%)
- 느려진 지점은 원인 기록 후 롤백/보완 판단

### 5. 종료 조건
- [ ] 모든 함수 시그니처 보존 확인
- [ ] 핵심 시나리오 전부 통과
- [ ] UI 비교 완료 (차이 없음)
- [ ] 성능 기준 충족
- [ ] 문서/주석 업데이트 (필요한 경우)
- [ ] 코드 리뷰 완료

---

## Code Smells (리팩토링이 필요한 신호)

### 주요 Code Smells
1. **중복 코드 (Duplicated Code)**
   - 같은 코드가 여러 곳에 존재
   - 해결: Extract Method, Extract Class

2. **긴 메서드 (Long Method)**
   - 한 메서드가 너무 많은 일을 함
   - 해결: Extract Method, Replace Temp with Query

3. **거대한 클래스 (Large Class)**
   - 한 클래스가 너무 많은 책임을 가짐
   - 해결: Extract Class, Extract Subclass

4. **긴 매개변수 목록 (Long Parameter List)**
   - 매개변수가 3-4개 이상
   - 해결: Introduce Parameter Object, Preserve Whole Object

5. **변경의 발산 (Divergent Change)**
   - 한 클래스가 여러 이유로 자주 변경됨
   - 해결: Extract Class로 책임 분리

6. **기능의 산재 (Shotgun Surgery)**
   - 한 기능 변경 시 여러 클래스를 수정해야 함
   - 해결: Move Method, Move Field

7. **기능 부러움 (Feature Envy)**
   - 메서드가 다른 클래스의 데이터를 더 많이 사용
   - 해결: Move Method, Extract Method

8. **데이터 뭉치 (Data Clumps)**
   - 같은 데이터들이 여러 곳에 함께 나타남
   - 해결: Extract Class, Introduce Parameter Object

9. **기본 타입 집착 (Primitive Obsession)**
   - 객체 대신 기본 타입만 사용
   - 해결: Replace Primitive with Object

10. **스위치 문 (Switch Statements)**
    - 동일한 switch/if-else가 여러 곳에 존재
    - 해결: Replace Conditional with Polymorphism

---

## 리팩토링 카탈로그 (주요 기법)

### 메서드 정리
- **Extract Method**: 코드 조각을 메서드로 추출
- **Inline Method**: 메서드 본문을 호출부에 직접 삽입
- **Rename Method**: 메서드명을 의도가 드러나게 변경
- **Add Parameter**: 메서드에 매개변수 추가
- **Remove Parameter**: 사용하지 않는 매개변수 제거

### 객체 간 기능 이동
- **Move Method**: 메서드를 더 적절한 클래스로 이동
- **Move Field**: 필드를 더 적절한 클래스로 이동
- **Extract Class**: 클래스의 일부를 새 클래스로 분리
- **Inline Class**: 작은 클래스를 다른 클래스에 합병

### 데이터 체계화
- **Replace Magic Number with Constant**: 매직 넘버를 상수로 대체
- **Encapsulate Field**: 필드를 private으로, getter/setter 제공
- **Replace Type Code with Class**: 타입 코드를 클래스로 대체
- **Replace Array with Object**: 배열을 객체로 대체

### 조건문 간소화
- **Decompose Conditional**: 조건문을 메서드로 추출
- **Consolidate Conditional Expression**: 중복 조건문 통합
- **Remove Control Flag**: 제어 플래그를 break/return으로 대체
- **Replace Nested Conditional with Guard Clauses**: 중첩 조건문을 보호 구문으로 대체

### 메서드 호출 단순화
- **Rename Method**: 메서드명 변경
- **Add Parameter**: 매개변수 추가
- **Remove Parameter**: 매개변수 제거
- **Separate Query from Modifier**: 질의와 변경 분리
- **Parameterize Method**: 여러 메서드를 매개변수화된 하나로 통합

---

## SOLID 원칙을 향한 리팩토링

### S - Single Responsibility Principle (단일 책임)
- 한 클래스는 하나의 책임만 가져야 함
- 변경의 이유가 하나여야 함

### O - Open/Closed Principle (개방-폐쇄)
- 확장에는 열려있고, 수정에는 닫혀있어야 함
- 기존 코드 수정 없이 기능 추가 가능

### L - Liskov Substitution Principle (리스코프 치환)
- 자식 클래스는 부모 클래스를 대체할 수 있어야 함

### I - Interface Segregation Principle (인터페이스 분리)
- 클라이언트는 사용하지 않는 메서드에 의존하지 않아야 함

### D - Dependency Inversion Principle (의존성 역전)
- 고수준 모듈은 저수준 모듈에 의존하지 않아야 함
- 둘 다 추상화에 의존해야 함

---

## 위험 신호 (즉시 중단/롤백 고려)

### 즉시 롤백
- 앱 기동 불가 또는 주요 기능 실패
- UI가 의도와 다르게 변형됨
- 데이터 손실/오염 의심
- 성능 급락 (예: 50% 이상)
- **함수 시그니처 변경으로 호출부 에러 발생**
- **기존 테스트 실패**

### 중단 후 검토
- 예상보다 변경 범위가 커질 때
- 연쇄적인 수정이 필요할 때
- 확신이 없을 때

---

## 전체 체크리스트

### 사전 준비
- [ ] **리팩토링 계획서 작성**
  - [ ] 변경 대상 함수 목록 작성
  - [ ] 보존 대상 함수 목록 작성
  - [ ] 영향 범위 분석 완료
- [ ] 변경 대상/보존 대상 구분하여 기록
- [ ] 테스트/시나리오/화면 기준선 확보
- [ ] 롤백 브랜치/태그 생성

### 리팩토링 중
- [ ] 한 번에 하나의 변경만 적용
- [ ] 변경마다 즉시 테스트 수행
- [ ] **보존 대상**: 시그니처 변경 없음 확인
- [ ] **변경 대상**: 계획된 범위 내 변경 확인
- [ ] 전체 재작성 금지 준수

### 리팩토링 후
- [ ] **보존 대상**: 시그니처 완전 보존 확인
- [ ] **변경 대상**: 계획대로 변경 완료 확인
- [ ] 모든 호출부 마이그레이션 완료
- [ ] 기능/UI/API 동일성 확인 (변경 대상 제외)
- [ ] 성능 변화 확인 (±10% 이내)
- [ ] 테스트 업데이트 및 통과 확인
- [ ] 롤백 가능 상태 유지

---
*Last Updated: 2026-01-06*