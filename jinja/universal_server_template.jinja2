"""
{%- if protocol_type == 'rest' %}
FastAPI MCP Server for {{ server_title | default(server_name | title) }}
Routes MCP protocol requests to service functions
{%- elif protocol_type == 'stdio' %}
STDIO MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via standard input/output
{%- elif protocol_type == 'stream' %}
Streaming MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via HTTP streaming (SSE)
{%- else %}
MCP Server for {{ server_title | default(server_name | title) }}
{%- endif %}
Generated from universal template with registry data and protocol selection
"""
import json
from typing import Dict, Any, List, Optional
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
{%- endif %}
from pydantic import BaseModel
import sys
import os
import logging
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
import aiohttp
{%- endif %}
{%- if protocol_type == 'stdio' or protocol_type == 'stream' %}
import asyncio
from typing import AsyncIterator
{%- endif %}

# Add parent directories to path for module access
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
grandparent_dir = os.path.dirname(parent_dir)

# Add paths for imports based on server type
{%- if server_name == 'file_handler' %}
file_handler_dir = os.path.join(grandparent_dir, "mcp_file_handler")
sys.path.insert(0, file_handler_dir)  # For file_handler relative imports
{%- endif %}
sys.path.insert(0, grandparent_dir)  # For session module and package imports
sys.path.insert(0, parent_dir)  # For direct module imports

# Import types dynamically based on type_info
{%- if type_info and type_info.type_locations %}
{%- set imports = {} %}
{%- for type_name in type_info.all_types %}
{%- if type_name in type_info.type_locations %}
{%- set loc = type_info.type_locations[type_name] %}
{%- if loc.module not in imports %}
{%- set _ = imports.update({loc.module: []}) %}
{%- endif %}
{%- set _ = imports[loc.module].append(type_name) %}
{%- endif %}
{%- endfor %}
{%- for module, types in imports.items() %}
from {{ module }} import {{ types | join(', ') }}
{%- endfor %}
{%- elif param_types %}
# Fallback to simple import if type_locations not available
from {{ server_name }}_types import {{ param_types | join(', ') }}
{%- endif %}

# Import tool definitions
try:
    from .tool_definitions import MCP_TOOLS
except ImportError:
    from tool_definitions import MCP_TOOLS

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

{#- Build unique services dict to avoid duplicate imports #}
{%- set unique_services = {} %}
{%- for service_name, service_info in services.items() %}
{%- set key = service_info.class_name ~ '|' ~ service_info.module_path %}
{%- if key not in unique_services %}
{%- set _ = unique_services.update({key: service_info}) %}
{%- endif %}
{%- endfor %}

# Import service classes (unique)
{%- for key, service_info in unique_services.items() %}
{%- set module_name = service_info.module_path.split('.')[-1] %}
{%- if not service_info.module_path.startswith('mcp_') %}
from mcp_{{ server_name }}.{{ module_name }} import {{ service_info.class_name }}
{%- else %}
from {{ service_info.module_path }} import {{ service_info.class_name }}
{%- endif %}
{%- endfor %}

# Create service instances
{%- for key, service_info in unique_services.items() %}
{{ service_info.instance }} = {{ service_info.class_name }}()
{%- endfor %}

# ============================================================
# Common MCP protocol utilities (shared across protocols)
# ============================================================

SUPPORTED_PROTOCOLS = {"rest", "stdio", "stream"}

# Pre-computed tool -> implementation mapping
TOOL_IMPLEMENTATIONS = {
{%- for tool in tools %}
    "{{ tool.name }}": {
        "service_class": "{{ tool.implementation.class_name }}",
        "method": "{{ tool.implementation.method or tool.service_method or tool.name }}"
    },
{%- endfor %}
}

# Pre-computed service class -> instance mapping
SERVICE_INSTANCES = {
{%- for key, service_info in unique_services.items() %}
    "{{ service_info.class_name }}": {{ service_info.instance }},
{%- endfor %}
}


def get_tool_config(tool_name: str) -> Optional[dict]:
    """Lookup MCP tool definition by name"""
    for tool in MCP_TOOLS:
        if tool.get("name") == tool_name:
            return tool
    return None


def get_tool_implementation(tool_name: str) -> Optional[dict]:
    """Get implementation mapping for a tool"""
    return TOOL_IMPLEMENTATIONS.get(tool_name)


def get_service_instance(service_class: str):
    """Get instantiated service by class name"""
    return SERVICE_INSTANCES.get(service_class)


def format_tool_result(result: Any) -> Dict[str, Any]:
    """Normalize service results into a consistent MCP payload"""
    if isinstance(result, dict):
        return result
    if isinstance(result, list):
        return {"items": result}
    if isinstance(result, str):
        return {"message": result}
    if result is None:
        return {"success": True}
    return {"result": str(result)}


def build_mcp_content(payload: Dict[str, Any]) -> Dict[str, Any]:
    """Wrap normalized payload into MCP content envelope"""
    return {
        "result": {
            "content": [
                {
                    "type": "text",
                    "text": json.dumps(payload, ensure_ascii=False, indent=2)
                }
            ]
        }
    }


# ============================================================
# Internal Args Support
# ============================================================
# Internal args are now embedded in tool definitions via mcp_service_factors
# This data is passed from the generator as part of the context
INTERNAL_ARGS = {{ internal_args | pprint }}

# Build INTERNAL_ARG_TYPES dynamically based on imported types
INTERNAL_ARG_TYPES = {}
{%- for param_type in param_types %}
if '{{ param_type }}' in globals():
    INTERNAL_ARG_TYPES['{{ param_type }}'] = {{ param_type }}
{%- endfor %}


def extract_schema_defaults(arg_info: dict) -> dict:
    """Extract default values from original_schema.properties."""
    original_schema = arg_info.get("original_schema", {})
    properties = original_schema.get("properties", {})
    defaults = {}
    for prop_name, prop_def in properties.items():
        if "default" in prop_def:
            defaults[prop_name] = prop_def["default"]
    return defaults


def build_internal_param(tool_name: str, arg_name: str, runtime_value: dict = None):
    """Instantiate internal parameter object for a tool.

    Value resolution priority:
    1. runtime_value: Dynamic value passed from function arguments at runtime
    2. stored value: Value from tool_internal_args.json
    3. defaults: Static value from original_schema.properties
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return None

    param_cls = INTERNAL_ARG_TYPES.get(arg_info.get("type"))
    if not param_cls:
        logger.warning(f"Unknown internal arg type for {tool_name}.{arg_name}: {arg_info.get('type')}")
        return None

    defaults = extract_schema_defaults(arg_info)
    stored_value = arg_info.get("value")

    if runtime_value is not None and runtime_value != {}:
        final_value = {**defaults, **runtime_value}
    elif stored_value is not None and stored_value != {}:
        final_value = {**defaults, **stored_value}
    else:
        final_value = defaults

    if not final_value:
        return param_cls()

    try:
        return param_cls(**final_value)
    except Exception as exc:
        logger.warning(f"Failed to build internal arg {tool_name}.{arg_name}: {exc}")
        return None


def model_to_dict(model):
    if model is None:
        return {}
    if isinstance(model, dict):
        return model
    if hasattr(model, "model_dump"):
        return model.model_dump(exclude_none=True)
    if hasattr(model, "dict"):
        return model.dict(exclude_none=True)
    return {}


def merge_param_data(internal_data: dict, runtime_data):
    if not runtime_data:
        return internal_data or None
    if internal_data:
        return {**internal_data, **runtime_data}
    return runtime_data

# Tool handler functions
{%- for tool in tools %}

async def handle_{{ tool.tool_name or tool.name }}(args: Dict[str, Any]) -> Dict[str, Any]:
    """Handle {{ tool.name }} tool call"""
    {%- if tool.object_params %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    # Extract from input with source param name
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args["{{ source_param }}"]
    {%- elif param_info.has_default %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_raw = args.get("{{ source_param }}")
    {%- if param_info.type in enum_types %}
    # Handle enum type default
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default | replace('"', '') }}
    {%- else %}
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- endif %}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args.get("{{ source_param }}")
    {%- endif %}
    {%- endfor %}

    {%- if tool.internal_overrides %}
    # Internal overrides for object params
    {%- for base_name, override in tool.internal_overrides.items() %}
    {%- set arg_name = override.name %}
    {%- set arg_info = override.info %}
    {%- if arg_info.value is defined and arg_info.value is not none %}
    {{ arg_name }}_data = model_to_dict({{ arg_info.value | pprint }})
    {%- else %}
    {{ arg_name }}_params = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {{ arg_name }}_data = model_to_dict({{ arg_name }}_params)
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    # Convert dicts to parameter objects where needed
    {%- for param_name, param_info in tool.object_params.items() %}
    {%- if param_name not in tool.internal_args %}
    {%- if param_name in tool.internal_overrides %}
    {{ param_name }}_internal_data = {{ tool.internal_overrides[param_name].name }}_data
    {%- else %}
    {{ param_name }}_internal_data = {}
    {%- endif %}
    {%- if not param_info.is_optional %}
    # Use already extracted raw value or get from args
    {%- if param_name in tool.params %}
    # Value was already extracted above, use the existing variable
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}) or {}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_raw = args["{{ source_param }}"]
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw) or {}
    {%- endif %}
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data)
    {%- elif param_info.has_default %}
    # Use already extracted value if it exists
    {%- if param_name in tool.params %}
    # Value was already extracted above, use the existing variable
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }})
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_raw = args.get("{{ source_param }}")
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw)
    {%- endif %}
    if {{ param_name }}_data is not None:
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data)
    else:
        {%- if param_info.default_json %}
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_info.default_json }})
        {%- else %}
        {{ param_name }}_params = None
        {%- endif %}
    {%- else %}
    # Use already extracted value if it exists
    {%- if param_name in tool.params %}
    # Value was already extracted above, use the existing variable
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }})
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_raw = args.get("{{ source_param }}")
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw)
    {%- endif %}
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data) if {{ param_name }}_data is not None else None
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    # Prepare call arguments
    call_args = {}

    # Add signature parameters
    {%- for param_name, param_info in tool.call_params.items() %}
    call_args["{{ param_name }}"] = {{ param_info.value }}
    {%- endfor %}

    {%- if tool.internal_args %}
    # Process internal args with targetParam mappings
    {%- for arg_name, arg_info in tool.internal_args.items() %}
    {%- if not arg_name.endswith("_internal") %}
    {%- set target_param = arg_info.original_schema.targetParam | default(arg_info.targetParam) | default(arg_name) %}

    # Build internal arg: {{ arg_name }}
    {%- if arg_info.value is defined and arg_info.value is not none and arg_info.value != {} %}
    _internal_{{ arg_name }} = {{ arg_info.type }}(**{{ arg_info.value | pprint }})
    {%- elif arg_info.value is defined and arg_info.value == {} %}
    _internal_{{ arg_name }} = {{ arg_info.type }}()
    {%- else %}
    _internal_{{ arg_name }} = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {%- endif %}

    # Check if target param already exists from signature
    if "{{ target_param }}" in call_args:
        existing_value = call_args["{{ target_param }}"]
        if existing_value is None:
            # Signature value is None, use internal value
            if _internal_{{ arg_name }} is not None:
                call_args["{{ target_param }}"] = _internal_{{ arg_name }}
        elif hasattr(existing_value, '__dict__') and hasattr(_internal_{{ arg_name }}, '__dict__'):
            # Both are objects - merge them (signature has priority for non-None values)
            internal_dict = {k: v for k, v in vars(_internal_{{ arg_name }}).items() if v is not None}
            existing_dict = {k: v for k, v in vars(existing_value).items() if v is not None}
            merged_dict = {**internal_dict, **existing_dict}
            call_args["{{ target_param }}"] = type(existing_value)(**merged_dict)
        # Otherwise keep existing signature value (non-None primitive or incompatible types)
    else:
        # No conflict, use internal value with targetParam mapping
        if _internal_{{ arg_name }} is not None:
            call_args["{{ target_param }}"] = _internal_{{ arg_name }}
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    return await {{ tool.implementation.instance }}.{{ tool.implementation.method }}(**call_args)
    {%- else %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    # Extract from input with source param name
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args["{{ source_param }}"]
    {%- elif param_info.has_default %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_raw = args.get("{{ source_param }}")
    {%- if param_info.type in enum_types %}
    # Handle enum type default
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default | replace('"', '') }}
    {%- else %}
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- endif %}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args.get("{{ source_param }}")
    {%- endif %}
    {%- endfor %}

    return await {{ tool.implementation.instance }}.{{ tool.implementation.method }}(
        {%- for target_param, param_info in tool.call_params.items() %}
        {{ target_param }}={{ param_info.value }}{{ "," if not loop.last else "" }}
        {%- endfor %}
    )
    {%- endif %}
{%- endfor %}

{#- Include protocol-specific handlers based on protocol_type -#}
{%- if protocol_type == 'rest' %}
{% include 'server_rest.jinja2' %}
{%- elif protocol_type == 'stdio' %}
{% include 'server_stdio.jinja2' %}
{%- elif protocol_type == 'stream' %}
{% include 'server_stream.jinja2' %}
{%- endif %}

if __name__ == "__main__":
{%- if protocol_type == 'rest' %}
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
{%- elif protocol_type == 'stdio' %}
    asyncio.run(handle_stdio())
{%- elif protocol_type == 'stream' %}
    handle_streamablehttp(host="0.0.0.0", port=8001)  # StreamableHTTP server
{%- else %}
    raise ValueError("Unsupported protocol_type: {{ protocol_type }}")
{%- endif %}
