"""
FastAPI MCP Server for {{ server_title | default(server_name | title) }}
Routes MCP protocol requests to service functions
Generated from universal template with registry data
"""
import json
from typing import Dict, Any, List, Optional
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import sys
import os
import logging

# Add parent directories to path for module access
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
grandparent_dir = os.path.dirname(parent_dir)

# Add paths for imports based on server type
{%- if server_name == 'file_handler' %}
file_handler_dir = os.path.join(grandparent_dir, "mcp_file_handler")
sys.path.insert(0, file_handler_dir)  # For file_handler relative imports
{%- endif %}
sys.path.insert(0, grandparent_dir)  # For session module and package imports
sys.path.insert(0, parent_dir)  # For direct module imports

# Import parameter types if needed
{%- if param_types %}
{%- if server_name == 'outlook' %}
from outlook_types import {{ param_types | join(', ') }}
{%- endif %}
{%- endif %}

# Import tool definitions
from tool_definitions import MCP_TOOLS

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

{#- Build unique services dict to avoid duplicate imports #}
{%- set unique_services = {} %}
{%- for service_name, service_info in services.items() %}
{%- set key = service_info.class_name ~ '|' ~ service_info.module_path %}
{%- if key not in unique_services %}
{%- set _ = unique_services.update({key: service_info}) %}
{%- endif %}
{%- endfor %}

# Import service classes (unique)
{%- for key, service_info in unique_services.items() %}
{%- if server_name == 'file_handler' %}
from {{ service_info.module_path.split('.')[-1] }} import {{ service_info.class_name }}
{%- else %}
from {{ service_info.module_path.replace('.', '_').replace('mcp_', '').replace('outlook_', '') }} import {{ service_info.class_name }}
{%- endif %}
{%- endfor %}

# Import session management
from session.session_manager import (
    session_manager,
    USE_SESSION_MANAGER,
    ensure_services_initialized_legacy,
    get_user_session_or_legacy,
)


# ============================================================
# Error Handling
# ============================================================
async def handle_token_error(e: Exception, user_email: str):
    """Handle token-related errors.

    If the error indicates an expired/invalid token and SessionManager is available,
    invalidate the session and raise 401. Otherwise, re-raise the original error.
    """
    if USE_SESSION_MANAGER and ("401" in str(e) or "unauthorized" in str(e).lower()):
        await session_manager.invalidate_session(user_email)
        raise HTTPException(status_code=401, detail="Access token expired")
    raise e


# ============================================================
# Service Instance Mapping
# ============================================================
# Map class names to instance names for service lookup
SERVICE_INSTANCE_MAP = {
{%- for key, service_info in unique_services.items() %}
    "{{ service_info.class_name }}": "{{ service_info.instance }}",
{%- endfor %}
}


def get_service_instance(class_name: str, context):
    """Get service instance by class name from session or legacy context.

    Args:
        class_name: Service class name (e.g., "GraphMailQuery")
        context: Session object or legacy dict with service instances

    Returns:
        Service instance or None
    """
    instance_name = SERVICE_INSTANCE_MAP.get(class_name)
    if not instance_name:
        logger.warning(f"Unknown service class: {class_name}")
        return None

    if USE_SESSION_MANAGER:
        return getattr(context, instance_name, None)
    else:
        return context.get(instance_name)


# ============================================================
# Internal Args Support
# ============================================================
def load_internal_args() -> dict:
    """Load internal args from tool_internal_args.json"""
    possible_paths = [
        os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "mcp_editor", "mcp_{{ server_name }}", "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "tool_internal_args.json"),
    ]
    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    raw_args = json.load(f)
                logger.info(f"Loaded internal args from {path}")
                return raw_args
            except Exception as exc:
                logger.warning(f"Failed to load internal args from {path}: {exc}")
    return {}


INTERNAL_ARGS = load_internal_args()

# Build INTERNAL_ARG_TYPES dynamically based on imported types
INTERNAL_ARG_TYPES = {}
{%- for param_type in param_types %}
if '{{ param_type }}' in globals():
    INTERNAL_ARG_TYPES['{{ param_type }}'] = {{ param_type }}
{%- endfor %}


def extract_schema_defaults(arg_info: dict) -> dict:
    """Extract default values from original_schema.properties."""
    original_schema = arg_info.get("original_schema", {})
    properties = original_schema.get("properties", {})
    defaults = {}
    for prop_name, prop_def in properties.items():
        if "default" in prop_def:
            defaults[prop_name] = prop_def["default"]
    return defaults


def build_internal_param(tool_name: str, arg_name: str, runtime_value: dict = None):
    """Instantiate internal parameter object for a tool.

    Value resolution priority:
    1. runtime_value: Dynamic value passed from function arguments at runtime
    2. stored value: Value from tool_internal_args.json
    3. defaults: Static value from original_schema.properties
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return None

    param_cls = INTERNAL_ARG_TYPES.get(arg_info.get("type"))
    if not param_cls:
        logger.warning(f"Unknown internal arg type for {tool_name}.{arg_name}: {arg_info.get('type')}")
        return None

    defaults = extract_schema_defaults(arg_info)
    stored_value = arg_info.get("value")

    if runtime_value is not None and runtime_value != {}:
        final_value = {**defaults, **runtime_value}
    elif stored_value is not None and stored_value != {}:
        final_value = {**defaults, **stored_value}
    else:
        final_value = defaults

    if not final_value:
        return param_cls()

    try:
        return param_cls(**final_value)
    except Exception as exc:
        logger.warning(f"Failed to build internal arg {tool_name}.{arg_name}: {exc}")
        return None


app = FastAPI(title="{{ server_title | default(server_name | title + ' MCP Server') }}", version="1.0.0")


@app.on_event("startup")
async def startup_event():
    """Start SessionManager on server startup (if available)"""
    if USE_SESSION_MANAGER:
        await session_manager.start()
        logger.info("SessionManager started")
    else:
        logger.info("Server started in legacy mode without SessionManager")


@app.on_event("shutdown")
async def shutdown_event():
    """Stop SessionManager on server shutdown (if available)"""
    if USE_SESSION_MANAGER:
        await session_manager.stop()
        logger.info("SessionManager stopped")
    else:
        logger.info("Server shutdown in legacy mode")


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "name": "{{ server_title | default(server_name | title + ' MCP Server') }}",
        "version": "1.0.0",
        "session_manager_enabled": USE_SESSION_MANAGER
    }


@app.post("/mcp/v1/tools/list")
async def list_tools(request: Request):
    """List available MCP tools"""
    try:
        # Get tools metadata
        tools_list = []
        for tool in MCP_TOOLS:
            tools_list.append({
                "name": tool["name"],
                "description": tool.get("description", ""),
                "inputSchema": tool.get("inputSchema", {})
            })

        return JSONResponse(content={
            "result": {
                "tools": tools_list
            }
        })
    except Exception as e:
        logger.error(f"Error listing tools: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": {"message": str(e)}}
        )


@app.post("/mcp/v1/tools/call")
async def call_tool(request: Request):
    """Execute an MCP tool"""
    try:
        data = await request.json()
        tool_name = data.get("params", {}).get("name")
        arguments = data.get("params", {}).get("arguments", {})

        logger.info(f"Tool call: {tool_name} with args: {arguments}")

        # Map tool name to service implementation
        tool_implementations = {
{%- for tool in tools %}
            "{{ tool.name }}": {
                "service_class": "{{ tool.implementation.class_name }}",
                "method": "{{ tool.implementation.method }}"
            },
{%- endfor %}
        }

        if tool_name not in tool_implementations:
            return JSONResponse(
                status_code=404,
                content={"error": {"message": f"Unknown tool: {tool_name}"}}
            )

        implementation_info = tool_implementations[tool_name]

        # Get session or use legacy mode
        session = None
        user_email = arguments.get("user_email")

        if USE_SESSION_MANAGER and user_email:
            session = await session_manager.get_or_create_session(user_email)
        else:
            await ensure_services_initialized_legacy(user_email)

        # Get service instance
        service_instance = get_service_instance(implementation_info["service_class"], session)

        if not service_instance:
            return JSONResponse(
                status_code=500,
                content={"error": {"message": f"Service not available: {implementation_info['service_class']}"}}
            )

        # Get the method
        method = getattr(service_instance, implementation_info["method"], None)
        if not method:
            return JSONResponse(
                status_code=500,
                content={"error": {"message": f"Method not found: {implementation_info['method']}"}}
            )

        # Process arguments based on tool configuration
{%- if server_name == 'outlook' %}
        # Handle parameter transformations for outlook tools
        processed_args = {}

        # Get tool configuration
        tool_config = next((t for t in MCP_TOOLS if t["name"] == tool_name), None)

        if tool_config:
            schema_props = tool_config.get("inputSchema", {}).get("properties", {})

            for param_name, param_value in arguments.items():
                param_schema = schema_props.get(param_name, {})

                # Transform object parameters to their expected types
                if param_schema.get("type") == "object":
                    base_model = param_schema.get("baseModel")
                    if base_model == "FilterParams":
                        processed_args["filter"] = FilterParams(**param_value) if param_value else None
                    elif base_model == "ExcludeParams":
                        if "exclude" in implementation_info["method"] or "exclude" in param_name:
                            processed_args["exclude"] = ExcludeParams(**param_value) if param_value else None
                        else:
                            processed_args["client_filter"] = ExcludeParams(**param_value) if param_value else None
                    elif base_model == "SelectParams":
                        processed_args["select"] = SelectParams(**param_value) if param_value else None
                    else:
                        processed_args[param_name] = param_value
                else:
                    processed_args[param_name] = param_value
        else:
            processed_args = arguments
{%- else %}
        # Direct argument passing for other servers
        processed_args = arguments
{%- endif %}

        # Call the method
        result = await method(**processed_args)

        # Format response
        if isinstance(result, dict):
            response_content = result
        elif isinstance(result, list):
            response_content = {"items": result}
        elif isinstance(result, str):
            response_content = {"message": result}
        elif result is None:
            response_content = {"success": True}
        else:
            response_content = {"result": str(result)}

        return JSONResponse(content={
            "result": {
                "content": [
                    {
                        "type": "text",
                        "text": json.dumps(response_content, ensure_ascii=False, indent=2)
                    }
                ]
            }
        })

    except Exception as e:
        logger.error(f"Error executing tool {tool_name}: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": {"message": str(e)}}
        )

# Tool functions - routing to session-specific implementations
{%- for tool in tools %}

async def handle_{{ tool.tool_name or tool.name }}(args: Dict[str, Any]) -> Dict[str, Any]:
    """Route to {{ tool.implementation.class_name or tool.service_class }}.{{ tool.implementation.method or tool.service_method }} with session or legacy support"""
    # Get session or legacy instances (first operation)
    user_email = args["user_email"]
    context = await get_user_session_or_legacy(user_email, args.get("access_token"))

    {%- if tool.object_params %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() if param_name != 'user_email' %}
    {%- if param_info.is_required %}
    {{ param_name }} = args["{{ param_name }}"]
    {%- elif param_info.has_default %}
    # Optional with default: use default if LLM didn't provide value
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- else %}
    {{ param_name }} = args.get("{{ param_name }}")
    {%- endif %}
    {%- endfor %}

    # Convert dicts to parameter objects where needed (Signature params from args)
    {%- for param_name, param_info in tool.object_params.items() %}
    {%- if param_name not in tool.internal_args %}
    {#- Required parameter - must be provided by LLM #}
    {%- if not param_info.is_optional %}
    {{ param_name }}_params = {{ param_info.class_name }}(**args["{{ param_name }}"])
    {#- Optional parameter with default value (use is not None to accept empty objects/arrays) #}
    {%- elif param_info.has_default %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    if {{ param_name }}_raw is not None:
        # LLM provided a value (even empty {} or [] is valid)
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_raw)
    else:
        # LLM didn't provide value - use default from web editor
        {%- if param_info.default_json %}
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_info.default_json }})
        {%- else %}
        # Explicit null default or no default value
        {{ param_name }}_params = None
        {%- endif %}
    {#- Optional parameter without default #}
    {%- else %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_raw) if {{ param_name }}_raw is not None else None
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- if tool.internal_args %}

    # Internal Args (pre-configured defaults, not exposed to MCP signature)
    {%- for arg_name, arg_info in tool.internal_args.items() %}
    {%- if arg_info.value is defined and arg_info.value is not none and arg_info.value != {} %}
    # {{ arg_name }}: pre-configured default value
    {{ arg_name }}_params = {{ arg_info.type }}(**{{ arg_info.value | pprint }})
    {%- elif arg_info.value is defined and arg_info.value == {} %}
    # {{ arg_name }}: empty object - use default constructor
    {{ arg_name }}_params = {{ arg_info.type }}()
    {%- else %}
    # {{ arg_name }}: no value configured - extract defaults from original_schema
    {{ arg_name }}_params = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    try:
        # Get the correct service instance
        service_instance = get_service_instance("{{ tool.implementation.class_name }}", context)

        return await service_instance.{{ tool.implementation.method or tool.mcp_service or tool.service_method }}(
            user_email=user_email,
            {%- for param_name, param_info in tool.call_params.items() if param_name != 'user_email' %}
            {{ param_name }}={{ param_info.value }}{{ "," if not loop.last else "" }}
            {%- endfor %}
        )
    except Exception as e:
        await handle_token_error(e, user_email)
    {%- else %}

    try:
        # Get the correct service instance
        service_instance = get_service_instance("{{ tool.implementation.class_name }}", context)

        {#- Extract parameters with proper default handling #}
        {%- for param_name, param_info in tool.params.items() %}
        {%- if param_info.is_required %}
        {{ param_name }} = args["{{ param_name }}"]
        {%- elif param_info.has_default %}
        # Optional with default: use default if LLM didn't provide value
        {{ param_name }}_raw = args.get("{{ param_name }}")
        {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
        {%- else %}
        {{ param_name }} = args.get("{{ param_name }}")
        {%- endif %}
        {%- endfor %}

        return await service_instance.{{ tool.implementation.method or tool.mcp_service or tool.service_method }}(
            {%- for param_name, param_info in tool.params.items() %}
            {{ param_name }}={{ param_name }}{{ "," if not loop.last else "" }}
            {%- endfor %}
        )
    except Exception as e:
        await handle_token_error(e, user_email)
    {%- endif %}
{%- endfor %}


def create_error_response(id: Any, code: int, message: str) -> JSONResponse:
    """Create MCP error response"""
    return JSONResponse(content={
        "jsonrpc": "2.0",
        "id": id,
        "error": {
            "code": code,
            "message": message
        }
    })

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)