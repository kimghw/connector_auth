"""
{%- if protocol_type == 'rest' %}
FastAPI MCP Server for {{ server_title | default(server_name | title) }}
Routes MCP protocol requests to service functions
{%- elif protocol_type == 'stdio' %}
STDIO MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via standard input/output
{%- elif protocol_type == 'stream' %}
Streaming MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via HTTP streaming (SSE)
{%- else %}
MCP Server for {{ server_title | default(server_name | title) }}
{%- endif %}
Generated from universal template with registry data and protocol selection
"""
import json
from typing import Dict, Any, List, Optional
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
{%- endif %}
from pydantic import BaseModel
import sys
import os
import logging
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
import aiohttp
{%- endif %}
{%- if protocol_type == 'stdio' or protocol_type == 'stream' %}
import asyncio
from typing import AsyncIterator
{%- endif %}

# Add parent directories to path for module access
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
grandparent_dir = os.path.dirname(parent_dir)

# Add paths for imports based on server type
{%- if server_name == 'file_handler' %}
file_handler_dir = os.path.join(grandparent_dir, "mcp_file_handler")
sys.path.insert(0, file_handler_dir)  # For file_handler relative imports
{%- endif %}
sys.path.insert(0, grandparent_dir)  # For session module and package imports
sys.path.insert(0, parent_dir)  # For direct module imports

# Import parameter types if needed
{%- if param_types %}
{%- if server_name == 'outlook' %}
from outlook_types import {{ param_types | join(', ') }}
{%- endif %}
{%- endif %}

# Import tool definitions
try:
    from .tool_definitions import MCP_TOOLS
except ImportError:
    from tool_definitions import MCP_TOOLS

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

{#- Build unique services dict to avoid duplicate imports #}
{%- set unique_services = {} %}
{%- for service_name, service_info in services.items() %}
{%- set key = service_info.class_name ~ '|' ~ service_info.module_path %}
{%- if key not in unique_services %}
{%- set _ = unique_services.update({key: service_info}) %}
{%- endif %}
{%- endfor %}

# Import service classes (unique)
{%- for key, service_info in unique_services.items() %}
from {{ service_info.module_path.split('.')[-1] }} import {{ service_info.class_name }}
{%- endfor %}

# Create service instances
{%- for key, service_info in unique_services.items() %}
{{ service_info.instance }} = {{ service_info.class_name }}()
{%- endfor %}

{%- include 'protocol_base.jinja2' %}


# ============================================================
# Internal Args Support
# ============================================================
def load_internal_args() -> dict:
    """Load internal args from tool_internal_args.json"""
    possible_paths = [
        os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "mcp_editor", "mcp_{{ server_name }}", "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "tool_internal_args.json"),
    ]
    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    raw_args = json.load(f)
                logger.info(f"Loaded internal args from {path}")
                return raw_args
            except Exception as exc:
                logger.warning(f"Failed to load internal args from {path}: {exc}")
    return {}


INTERNAL_ARGS = load_internal_args()

# Build INTERNAL_ARG_TYPES dynamically based on imported types
INTERNAL_ARG_TYPES = {}
{%- for param_type in param_types %}
if '{{ param_type }}' in globals():
    INTERNAL_ARG_TYPES['{{ param_type }}'] = {{ param_type }}
{%- endfor %}


def extract_schema_defaults(arg_info: dict) -> dict:
    """Extract default values from original_schema.properties."""
    original_schema = arg_info.get("original_schema", {})
    properties = original_schema.get("properties", {})
    defaults = {}
    for prop_name, prop_def in properties.items():
        if "default" in prop_def:
            defaults[prop_name] = prop_def["default"]
    return defaults


def build_internal_param(tool_name: str, arg_name: str, runtime_value: dict = None):
    """Instantiate internal parameter object for a tool.

    Value resolution priority:
    1. runtime_value: Dynamic value passed from function arguments at runtime
    2. stored value: Value from tool_internal_args.json
    3. defaults: Static value from original_schema.properties
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return None

    param_cls = INTERNAL_ARG_TYPES.get(arg_info.get("type"))
    if not param_cls:
        logger.warning(f"Unknown internal arg type for {tool_name}.{arg_name}: {arg_info.get('type')}")
        return None

    defaults = extract_schema_defaults(arg_info)
    stored_value = arg_info.get("value")

    if runtime_value is not None and runtime_value != {}:
        final_value = {**defaults, **runtime_value}
    elif stored_value is not None and stored_value != {}:
        final_value = {**defaults, **stored_value}
    else:
        final_value = defaults

    if not final_value:
        return param_cls()

    try:
        return param_cls(**final_value)
    except Exception as exc:
        logger.warning(f"Failed to build internal arg {tool_name}.{arg_name}: {exc}")
        return None


def model_to_dict(model):
    if model is None:
        return {}
    if isinstance(model, dict):
        return model
    if hasattr(model, "model_dump"):
        return model.model_dump(exclude_none=True)
    if hasattr(model, "dict"):
        return model.dict(exclude_none=True)
    return {}


def merge_param_data(internal_data: dict, runtime_data):
    if not runtime_data:
        return internal_data or None
    if internal_data:
        return {**internal_data, **runtime_data}
    return runtime_data

# Tool handler functions
{%- for tool in tools %}

async def handle_{{ tool.tool_name or tool.name }}(args: Dict[str, Any]) -> Dict[str, Any]:
    """Handle {{ tool.name }} tool call"""
    {%- if tool.object_params %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    {{ param_name }} = args["{{ param_name }}"]
    {%- elif param_info.has_default %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- else %}
    {{ param_name }} = args.get("{{ param_name }}")
    {%- endif %}
    {%- endfor %}

    {%- if tool.internal_overrides %}
    # Internal overrides for object params
    {%- for base_name, override in tool.internal_overrides.items() %}
    {%- set arg_name = override.name %}
    {%- set arg_info = override.info %}
    {%- if arg_info.value is defined and arg_info.value is not none %}
    {{ arg_name }}_data = model_to_dict({{ arg_info.value | pprint }})
    {%- else %}
    {{ arg_name }}_params = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {{ arg_name }}_data = model_to_dict({{ arg_name }}_params)
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    # Convert dicts to parameter objects where needed
    {%- for param_name, param_info in tool.object_params.items() %}
    {%- if param_name not in tool.internal_args %}
    {%- if param_name in tool.internal_overrides %}
    {{ param_name }}_internal_data = {{ tool.internal_overrides[param_name].name }}_data
    {%- else %}
    {{ param_name }}_internal_data = {}
    {%- endif %}
    {%- if not param_info.is_optional %}
    {{ param_name }}_raw = args["{{ param_name }}"]
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw) or {}
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data)
    {%- elif param_info.has_default %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw)
    if {{ param_name }}_data is not None:
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data)
    else:
        {%- if param_info.default_json %}
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_info.default_json }})
        {%- else %}
        {{ param_name }}_params = None
        {%- endif %}
    {%- else %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }}_data = merge_param_data({{ param_name }}_internal_data, {{ param_name }}_raw)
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_data) if {{ param_name }}_data is not None else None
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    # Prepare call arguments
    call_args = {}

    # Add signature parameters
    {%- for param_name, param_info in tool.call_params.items() %}
    call_args["{{ param_name }}"] = {{ param_info.value }}
    {%- endfor %}

    {%- if tool.internal_args %}
    # Process internal args with targetParam mappings
    {%- for arg_name, arg_info in tool.internal_args.items() %}
    {%- if not arg_name.endswith("_internal") %}
    {%- set target_param = arg_info.original_schema.targetParam | default(arg_info.targetParam) | default(arg_name) %}

    # Build internal arg: {{ arg_name }}
    {%- if arg_info.value is defined and arg_info.value is not none and arg_info.value != {} %}
    _internal_{{ arg_name }} = {{ arg_info.type }}(**{{ arg_info.value | pprint }})
    {%- elif arg_info.value is defined and arg_info.value == {} %}
    _internal_{{ arg_name }} = {{ arg_info.type }}()
    {%- else %}
    _internal_{{ arg_name }} = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {%- endif %}

    # Check if target param already exists from signature
    if "{{ target_param }}" in call_args:
        # Merge internal into signature (signature has priority, but skip None values)
        existing_value = call_args["{{ target_param }}"]
        if hasattr(existing_value, '__dict__') and hasattr(_internal_{{ arg_name }}, '__dict__'):
            # Both are objects - merge them (exclude None values from existing)
            internal_dict = {k: v for k, v in vars(_internal_{{ arg_name }}).items() if v is not None}
            existing_dict = {k: v for k, v in vars(existing_value).items() if v is not None}
            merged_dict = {**internal_dict, **existing_dict}
            call_args["{{ target_param }}"] = type(existing_value)(**merged_dict)
        # Otherwise keep existing signature value
    else:
        # No conflict, use internal value with targetParam mapping
        call_args["{{ target_param }}"] = _internal_{{ arg_name }}
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    return await {{ tool.implementation.instance }}.{{ tool.implementation.method or tool.mcp_service or tool.service_method }}(**call_args)
    {%- else %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    {{ param_name }} = args["{{ param_name }}"]
    {%- elif param_info.has_default %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- else %}
    {{ param_name }} = args.get("{{ param_name }}")
    {%- endif %}
    {%- endfor %}

    return await {{ tool.implementation.instance }}.{{ tool.implementation.method or tool.mcp_service or tool.service_method }}(
        {%- for param_name, param_info in tool.params.items() %}
        {{ param_name }}={{ param_name }}{{ "," if not loop.last else "" }}
        {%- endfor %}
    )
    {%- endif %}
{%- endfor %}

{#- Include protocol-specific handlers based on protocol_type -#}
{%- if protocol_type == 'rest' %}
{% include 'server_rest.jinja2' %}
{%- elif protocol_type == 'stdio' %}
{% include 'server_stdio.jinja2' %}
{%- elif protocol_type == 'stream' %}
{% include 'server_stream.jinja2' %}
{%- endif %}

if __name__ == "__main__":
{%- if protocol_type == 'rest' %}
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
{%- elif protocol_type == 'stdio' %}
    asyncio.run(handle_stdio())
{%- elif protocol_type == 'stream' %}
    handle_streamablehttp(host="0.0.0.0", port=8001)  # StreamableHTTP server
{%- else %}
    raise ValueError("Unsupported protocol_type: {{ protocol_type }}")
{%- endif %}
