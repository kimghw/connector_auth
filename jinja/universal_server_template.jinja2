"""
{%- if protocol_type == 'rest' %}
FastAPI MCP Server for {{ server_title | default(server_name | title) }}
Routes MCP protocol requests to service functions
{%- elif protocol_type == 'stdio' %}
STDIO MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via standard input/output
{%- elif protocol_type == 'stream' %}
Streaming MCP Server for {{ server_title | default(server_name | title) }}
Handles MCP protocol via HTTP streaming (SSE)
{%- else %}
MCP Server for {{ server_title | default(server_name | title) }}
{%- endif %}
Generated from universal template with registry data and protocol selection
"""
import json
import yaml
from pathlib import Path
from typing import Dict, Any, List, Optional
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
{%- endif %}
from pydantic import BaseModel
import sys
import os
import logging
{%- if protocol_type == 'rest' or protocol_type == 'stream' %}
import aiohttp
{%- endif %}
{%- if protocol_type == 'stdio' or protocol_type == 'stream' %}
import asyncio
from typing import AsyncIterator
{%- endif %}

# Add parent directories to path for module access
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
grandparent_dir = os.path.dirname(parent_dir)

# Add paths for imports (generalized for all servers)
server_module_dir = os.path.join(grandparent_dir, "mcp_{{ server_name }}")
if os.path.isdir(server_module_dir):
    sys.path.insert(0, server_module_dir)  # For server-specific relative imports
sys.path.insert(0, grandparent_dir)  # For session module and package imports
sys.path.insert(0, parent_dir)  # For direct module imports

# Import types dynamically based on type_info
{%- if type_info and type_info.type_locations %}
{%- set imports = {} %}
{%- for type_name in type_info.all_types %}
{%- if type_name in type_info.type_locations %}
{%- set loc = type_info.type_locations[type_name] %}
{%- if loc.module not in imports %}
{%- set _ = imports.update({loc.module: []}) %}
{%- endif %}
{%- set _ = imports[loc.module].append(type_name) %}
{%- endif %}
{%- endfor %}
{%- for module, types in imports.items() %}
from {{ module }} import {{ types | join(', ') }}
{%- endfor %}
{%- elif param_types %}
# Fallback to simple import if type_locations not available
from {{ server_name }}_types import {{ param_types | join(', ') }}
{%- endif %}

# Load tool definitions from YAML (Single Source of Truth)
def _load_mcp_tools() -> List[Dict[str, Any]]:
    """Load MCP tools from tool_definition_templates.yaml."""
    yaml_path = Path(current_dir).parent.parent / "mcp_editor" / "mcp_{{ server_name }}" / "tool_definition_templates.yaml"
    if yaml_path.exists():
        with open(yaml_path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
            return data.get("tools", [])
    raise FileNotFoundError(f"Tool definition YAML not found: {yaml_path}")

MCP_TOOLS = _load_mcp_tools()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

{#- Build unique services dict to avoid duplicate imports #}
{%- set unique_services = {} %}
{%- for service_name, service_info in services.items() %}
{%- set key = service_info.class_name ~ '|' ~ service_info.module_path %}
{%- if key not in unique_services %}
{%- set _ = unique_services.update({key: service_info}) %}
{%- endif %}
{%- endfor %}

# Import service classes (unique)
{%- for key, service_info in unique_services.items() %}
{%- set module_name = service_info.module_path.split('.')[-1] %}
{%- if not service_info.module_path.startswith('mcp_') %}
from mcp_{{ server_name }}.{{ module_name }} import {{ service_info.class_name }}
{%- else %}
from {{ service_info.module_path }} import {{ service_info.class_name }}
{%- endif %}
{%- endfor %}

# Create service instances
{%- for key, service_info in unique_services.items() %}
{{ service_info.instance }} = {{ service_info.class_name }}()
{%- endfor %}

# ============================================================
# Common MCP protocol utilities (shared across protocols)
# ============================================================

SUPPORTED_PROTOCOLS = {"rest", "stdio", "stream"}

# Pre-computed tool -> implementation mapping
TOOL_IMPLEMENTATIONS = {
{%- for tool in tools %}
{%- if not tool.implementation or not tool.implementation.method %}
{{ "ERROR: tool.implementation.method is not set for tool '" ~ tool.name ~ "'. Check mcp_service.name in tool_definition_templates.py and registry mapping." | raise_error }}
{%- endif %}
    "{{ tool.name }}": {
        "service_class": "{{ tool.implementation.class_name }}",
        "method": "{{ tool.implementation.method }}"
    },
{%- endfor %}
}

# Pre-computed service class -> instance mapping
SERVICE_INSTANCES = {
{%- for key, service_info in unique_services.items() %}
    "{{ service_info.class_name }}": {{ service_info.instance }},
{%- endfor %}
}


def get_tool_config(tool_name: str) -> Optional[dict]:
    """Lookup MCP tool definition by name"""
    for tool in MCP_TOOLS:
        if tool.get("name") == tool_name:
            return tool
    return None


def get_tool_implementation(tool_name: str) -> Optional[dict]:
    """Get implementation mapping for a tool"""
    return TOOL_IMPLEMENTATIONS.get(tool_name)


def get_service_instance(service_class: str):
    """Get instantiated service by class name"""
    return SERVICE_INSTANCES.get(service_class)


def format_tool_result(result: Any) -> Dict[str, Any]:
    """Normalize service results into a consistent MCP payload"""
    if isinstance(result, dict):
        return result
    if isinstance(result, list):
        return {"items": result}
    if isinstance(result, str):
        return {"message": result}
    if result is None:
        return {"success": True}
    return {"result": str(result)}


def build_mcp_content(payload: Dict[str, Any]) -> Dict[str, Any]:
    """Wrap normalized payload into MCP content envelope"""
    return {
        "result": {
            "content": [
                {
                    "type": "text",
                    "text": json.dumps(payload, ensure_ascii=False, indent=2)
                }
            ]
        }
    }


# ============================================================
# Service Factors Support (Internal + Signature Defaults)
# ============================================================
# Service factors are extracted at runtime from MCP_TOOLS mcp_service_factors
# Structure: { tool_name: { 'internal': {...}, 'signature_defaults': {...} } }


def _extract_service_factors(tools: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    """Extract service factors from mcp_service_factors in tool definitions at runtime.

    Returns:
        Dict with structure:
        {
            tool_name: {
                'internal': { factor_name: {...}, ... },
                'signature_defaults': { factor_name: {...}, ... }
            }
        }
    """
    service_factors = {}

    for tool in tools:
        tool_name = tool.get('name', '')
        mcp_service_factors = tool.get('mcp_service_factors', {})

        tool_factors = {
            'internal': {},
            'signature_defaults': {}
        }

        for factor_name, factor_data in mcp_service_factors.items():
            source = factor_data.get('source', '')

            # Only process 'internal' and 'signature_defaults' sources
            if source not in ('internal', 'signature_defaults'):
                continue

            # Support both 'type' (new) and 'baseModel' (legacy) field names
            factor_type = factor_data.get('type') or factor_data.get('baseModel', '')

            # targetParam handling
            target_param = factor_data.get('targetParam', factor_name)

            # Get parameters - handle both list format (new) and dict format (legacy)
            raw_params = factor_data.get('parameters', [])
            if isinstance(raw_params, list):
                params_dict = {}
                for param in raw_params:
                    name = param.get("name")
                    if not name:
                        continue
                    param_dict = {"type": param.get("type", "string")}
                    if param.get("has_default", False):
                        param_dict["default"] = param.get("default")
                    if param.get("description"):
                        param_dict["description"] = param["description"]
                    params_dict[name] = param_dict
            else:
                params_dict = raw_params  # Already a dict

            # Extract default values from parameters
            default_values = {}
            for param_name, param_def in params_dict.items():
                if 'default' in param_def:
                    default_values[param_name] = param_def['default']

            # Build the factor structure
            factor_info = {
                'targetParam': target_param,
                'type': factor_type,
                'source': source,
                'value': default_values,
                'original_schema': {
                    'targetParam': target_param,
                    'properties': params_dict,
                    'type': 'object'
                }
            }

            tool_factors[source][factor_name] = factor_info

        # Only add if there are any factors
        if tool_factors['internal'] or tool_factors['signature_defaults']:
            service_factors[tool_name] = tool_factors

    return service_factors


def _extract_internal_args(tools: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Extract internal args from service factors (legacy compatibility)."""
    service_factors = _extract_service_factors(tools)

    # Convert to legacy internal_args format
    internal_args = {}
    for tool_name, factors in service_factors.items():
        tool_internal = {}
        for factor_name, factor_info in factors.get('internal', {}).items():
            tool_internal[factor_name] = {
                'targetParam': factor_info['targetParam'],
                'type': factor_info['type'],
                'value': factor_info['value'],
                'original_schema': factor_info['original_schema']
            }
        if tool_internal:
            internal_args[tool_name] = tool_internal

    return internal_args


# MCP_TOOLS already loaded from YAML above (contains mcp_service_factors)
# Use it directly for service factors extraction

# Extract at module load time from MCP_TOOLS (which have mcp_service_factors)
SERVICE_FACTORS = _extract_service_factors(MCP_TOOLS)
INTERNAL_ARGS = _extract_internal_args(MCP_TOOLS)

# Build INTERNAL_ARG_TYPES dynamically based on imported types
INTERNAL_ARG_TYPES = {}
{%- for param_type in param_types %}
if '{{ param_type }}' in globals():
    INTERNAL_ARG_TYPES['{{ param_type }}'] = {{ param_type }}
{%- endfor %}


def extract_schema_defaults(arg_info: dict) -> dict:
    """Extract default values from original_schema.properties."""
    original_schema = arg_info.get("original_schema", {})
    properties = original_schema.get("properties", {})
    defaults = {}
    for prop_name, prop_def in properties.items():
        if "default" in prop_def:
            defaults[prop_name] = prop_def["default"]
    return defaults


def build_internal_param(tool_name: str, arg_name: str, runtime_value: dict = None):
    """Instantiate internal parameter object for a tool.

    Value resolution priority:
    1. runtime_value: Dynamic value passed from function arguments at runtime
    2. stored value: Value from INTERNAL_ARGS (generated from mcp_service_factors)
    3. defaults: Static value from original_schema.properties
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return None

    param_cls = INTERNAL_ARG_TYPES.get(arg_info.get("type"))
    if not param_cls:
        logger.warning(f"Unknown internal arg type for {tool_name}.{arg_name}: {arg_info.get('type')}")
        return None

    defaults = extract_schema_defaults(arg_info)
    stored_value = arg_info.get("value")

    if runtime_value is not None and runtime_value != {}:
        final_value = {**defaults, **runtime_value}
    elif stored_value is not None and stored_value != {}:
        final_value = {**defaults, **stored_value}
    else:
        final_value = defaults

    if not final_value:
        return param_cls()

    try:
        return param_cls(**final_value)
    except Exception as exc:
        logger.warning(f"Failed to build internal arg {tool_name}.{arg_name}: {exc}")
        return None


def get_signature_defaults(tool_name: str, factor_name: str) -> dict:
    """Get signature default values for a tool factor.

    Signature defaults are used to provide default values for user input parameters.
    These are applied when the user doesn't provide a value for an optional parameter.
    """
    tool_factors = SERVICE_FACTORS.get(tool_name, {})
    sig_defaults = tool_factors.get('signature_defaults', {})
    factor_info = sig_defaults.get(factor_name, {})
    return factor_info.get('value', {})


def apply_signature_defaults(signature_data: dict, tool_name: str, factor_name: str) -> dict:
    """Apply signature defaults to user-provided data.

    Merge order (priority high to low):
    1. User signature values (non-None)
    2. Signature defaults
    3. Schema defaults
    """
    if signature_data is None:
        signature_data = {}

    # Get signature defaults
    defaults = get_signature_defaults(tool_name, factor_name)
    if not defaults:
        return signature_data

    # Merge: defaults first, then user values override
    merged = {**defaults}
    for key, value in signature_data.items():
        if value is not None:
            merged[key] = value

    return merged


def merge_with_priority(signature_value, signature_defaults_value, internal_value):
    """Merge values with priority: Signature > Signature Defaults > Internal.

    Args:
        signature_value: User-provided value from LLM
        signature_defaults_value: Default value for user input
        internal_value: Hidden system value

    Returns:
        Final merged value with correct priority
    """
    # If all are None, return None
    if signature_value is None and signature_defaults_value is None and internal_value is None:
        return None

    # If signature has value, use it (possibly merged with defaults for objects)
    if signature_value is not None:
        # For dict/object types, merge with signature_defaults
        if isinstance(signature_value, dict):
            base = {}
            if internal_value and isinstance(internal_value, dict):
                base = {**internal_value}
            if signature_defaults_value and isinstance(signature_defaults_value, dict):
                base = {**base, **signature_defaults_value}
            return {**base, **signature_value}
        return signature_value

    # If signature is None but signature_defaults has value
    if signature_defaults_value is not None:
        if isinstance(signature_defaults_value, dict):
            base = {}
            if internal_value and isinstance(internal_value, dict):
                base = {**internal_value}
            return {**base, **signature_defaults_value}
        return signature_defaults_value

    # Fall back to internal value
    return internal_value


def model_to_dict(model):
    if model is None:
        return {}
    if isinstance(model, dict):
        return model
    if hasattr(model, "model_dump"):
        return model.model_dump(exclude_none=True)
    if hasattr(model, "dict"):
        return model.dict(exclude_none=True)
    return {}


def merge_param_data(internal_data: dict, runtime_data, signature_defaults: dict = None):
    """Merge parameter data with priority: runtime > signature_defaults > internal.

    Args:
        internal_data: Internal override data (lowest priority, not used for signature params)
        runtime_data: User-provided runtime data (highest priority)
        signature_defaults: Default values for signature params (middle priority)
    """
    # Start with internal data as base (if any)
    result = dict(internal_data) if internal_data else {}

    # Apply signature defaults (overrides internal)
    if signature_defaults:
        result = {**result, **signature_defaults}

    # Apply runtime data (highest priority, overrides all)
    if runtime_data:
        if isinstance(runtime_data, dict):
            result = {**result, **runtime_data}
        else:
            return runtime_data

    return result if result else None

# Tool handler functions
{%- for tool in tools %}

async def handle_{{ tool.tool_name or tool.name }}(args: Dict[str, Any]) -> Dict[str, Any]:
    """Handle {{ tool.name }} tool call"""
    {%- if tool.object_params %}

    # ========================================
    # Step 1: Signature 파라미터 수신
    # - LLM으로부터 전달받은 인자 추출
    # ========================================
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args["{{ source_param }}"]
    {%- elif param_info.has_default %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_sig = args.get("{{ source_param }}")
    {%- if param_info.type in enum_types %}
    {{ param_name }} = {{ param_name }}_sig if {{ param_name }}_sig is not None else {{ param_info.default | replace('"', '') }}
    {%- else %}
    {{ param_name }} = {{ param_name }}_sig if {{ param_name }}_sig is not None else {{ param_info.default_json }}
    {%- endif %}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args.get("{{ source_param }}")
    {%- endif %}
    {%- endfor %}

    # ========================================
    # Step 2: Signature Defaults 적용
    # - 사용자 입력이 없으면 기본값 병합
    # ========================================
    {%- for param_name, param_info in tool.object_params.items() %}
    {%- if param_name not in tool.internal_args %}
    {{ param_name }}_sig_defaults = {{ param_info.signature_defaults_values | default({}) | pprint }}
    {%- if not param_info.is_optional %}
    {%- if param_name in tool.params %}
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}, {{ param_name }}_sig_defaults) or {}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_sig = args["{{ source_param }}"]
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}_sig, {{ param_name }}_sig_defaults) or {}
    {%- endif %}
    {{ param_name }} = {{ param_info.class_name }}(**{{ param_name }}_data)
    {%- elif param_info.has_default %}
    {%- if param_name in tool.params %}
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}, {{ param_name }}_sig_defaults)
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_sig = args.get("{{ source_param }}")
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}_sig, {{ param_name }}_sig_defaults)
    {%- endif %}
    if {{ param_name }}_data is not None:
        {{ param_name }} = {{ param_info.class_name }}(**{{ param_name }}_data)
    else:
        {%- if param_info.default_json %}
        {{ param_name }} = {{ param_info.class_name }}(**{{ param_info.default_json }})
        {%- else %}
        {{ param_name }} = None
        {%- endif %}
    {%- else %}
    {%- if param_name in tool.params %}
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}, {{ param_name }}_sig_defaults)
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_sig = args.get("{{ source_param }}")
    {{ param_name }}_data = merge_param_data({}, {{ param_name }}_sig, {{ param_name }}_sig_defaults)
    {%- endif %}
    {{ param_name }} = {{ param_info.class_name }}(**{{ param_name }}_data) if {{ param_name }}_data is not None else None
    {%- endif %}
    {%- endif %}
    {%- endfor %}

    # ========================================
    # Step 3: 서비스 호출 인자 구성
    # - Signature 파라미터 추가
    # ========================================
    call_args = {}
    {%- for param_name, param_info in tool.call_params.items() %}
    call_args["{{ param_name }}"] = {{ param_info.value }}
    {%- endfor %}
    {%- if tool.internal_args %}

    # ========================================
    # Step 4: Internal 파라미터 추가
    # - LLM에 노출되지 않는 내부 고정값
    # ========================================
    {%- for arg_name, arg_info in tool.internal_args.items() %}
    {%- if not arg_name.endswith("_internal") %}
    {%- set target_param = arg_info.original_schema.targetParam | default(arg_info.targetParam) | default(arg_name) %}
    {%- if target_param not in tool.call_params %}
    {%- if arg_info.value is defined and arg_info.value is not none and arg_info.value != {} %}
    call_args["{{ target_param }}"] = {{ arg_info.type }}(**{{ arg_info.value | pprint }})
    {%- elif arg_info.value is defined and arg_info.value == {} %}
    call_args["{{ target_param }}"] = {{ arg_info.type }}()
    {%- else %}
    call_args["{{ target_param }}"] = build_internal_param("{{ tool.name }}", "{{ arg_name }}")
    {%- endif %}
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    # ========================================
    # Step 5: 서비스 메서드 호출
    # ========================================
    return await {{ tool.implementation.instance }}.{{ tool.implementation.method }}(**call_args)
    {%- else %}

    # ========================================
    # Step 1: Signature 파라미터 수신
    # - LLM으로부터 전달받은 인자 추출
    # ========================================
    {%- for param_name, param_info in tool.params.items() %}
    {%- if param_info.is_required %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args["{{ source_param }}"]
    {%- elif param_info.has_default %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }}_sig = args.get("{{ source_param }}")
    {%- if param_info.type in enum_types %}
    {{ param_name }} = {{ param_name }}_sig if {{ param_name }}_sig is not None else {{ param_info.default | replace('"', '') }}
    {%- else %}
    {{ param_name }} = {{ param_name }}_sig if {{ param_name }}_sig is not None else {{ param_info.default_json }}
    {%- endif %}
    {%- else %}
    {%- set source_param = tool.call_params[param_name].source_param if param_name in tool.call_params else param_name %}
    {{ param_name }} = args.get("{{ source_param }}")
    {%- endif %}
    {%- endfor %}

    # ========================================
    # Step 2: 서비스 호출 인자 구성
    # ========================================
    call_args = {}
    {%- for target_param, param_info in tool.call_params.items() %}
    call_args["{{ target_param }}"] = {{ param_info.value }}
    {%- endfor %}

    # ========================================
    # Step 3: 서비스 메서드 호출
    # ========================================
    return await {{ tool.implementation.instance }}.{{ tool.implementation.method }}(**call_args)
    {%- endif %}
{%- endfor %}

{#- Include protocol-specific handlers based on protocol_type -#}
{%- if protocol_type == 'rest' %}
{% include 'server_rest.jinja2' %}
{%- elif protocol_type == 'stdio' %}
{% include 'server_stdio.jinja2' %}
{%- elif protocol_type == 'stream' %}
{% include 'server_stream.jinja2' %}
{%- endif %}

if __name__ == "__main__":
{%- if protocol_type == 'rest' %}
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
{%- elif protocol_type == 'stdio' %}
    asyncio.run(handle_stdio())
{%- elif protocol_type == 'stream' %}
    handle_streamablehttp(host="0.0.0.0", port=8001)  # StreamableHTTP server
{%- else %}
    raise ValueError("Unsupported protocol_type: {{ protocol_type }}")
{%- endif %}
