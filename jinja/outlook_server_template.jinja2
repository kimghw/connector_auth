"""
FastAPI MCP Server for Outlook Graph Mail
Routes MCP protocol requests to existing Graph Mail functions
Now with SessionManager for safe multi-user support
"""
import json
from typing import Dict, Any, List, Optional
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
import sys
import os
import logging

# Add parent directories to path for module access
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
grandparent_dir = os.path.dirname(parent_dir)
sys.path.insert(0, grandparent_dir)  # For session module and package imports (mcp_file_handler, mcp_outlook)
sys.path.insert(0, parent_dir)  # For direct module imports from parent directory

{%- if 'GraphMailQuery' in services or 'GraphMailClient' in services %}
from outlook_types import {{ param_types | join(', ') }}
{%- endif %}
from tool_definitions import MCP_TOOLS

# Configure logging first
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Try to import SessionManager - optional feature
try:
    from session.session_manager import SessionManager
    session_manager = SessionManager()
    from session.session_manager import Session
    USE_SESSION_MANAGER = True
    logger.info("SessionManager imported successfully")
except ImportError:
    logger.warning("SessionManager not found, using legacy mode without session management")
    session_manager = None
    Session = None
    USE_SESSION_MANAGER = False

# Import legacy components for fallback
{%- if 'FileManager' in services or 'MetadataManager' in services %}
# File handler services use package-relative imports internally
# We need to import them as a package, not as standalone modules
{%- if 'FileManager' in services %}
from mcp_file_handler.file_manager import FileManager
{%- endif %}
{%- if 'MetadataManager' in services %}
from mcp_file_handler.metadata.manager import MetadataManager
{%- endif %}
{%- else %}
# Outlook services
{%- for service, info in services.items() %}
from {{ info.module }} import {{ service }}
{%- endfor %}
{%- endif %}

app = FastAPI(title="Outlook MCP Server", version="1.0.0")

# Global instances for legacy mode (when SessionManager not available)
if not USE_SESSION_MANAGER:
{%- for service, info in services.items() %}
    {{ info.instance_name }} = {{ service }}()
{%- endfor %}
{%- if 'FileManager' in services %}
    # FileManager contains metadata_manager
    metadata_manager = file_manager.metadata_manager
{%- endif %}


@app.on_event("startup")
async def startup_event():
    """Start SessionManager on server startup (if available)"""
    if USE_SESSION_MANAGER:
        await session_manager.start()
        logger.info("SessionManager started")
    else:
        logger.info("Server started in legacy mode without SessionManager")


@app.on_event("shutdown")
async def shutdown_event():
    """Stop SessionManager on server shutdown (if available)"""
    if USE_SESSION_MANAGER:
        await session_manager.stop()
        logger.info("SessionManager stopped")
    else:
        logger.info("Server shutdown in legacy mode")


async def ensure_graph_mail_client_legacy(user_email: Optional[str] = None):
    """
    Legacy method: Ensure GraphMailClient is initialized before use
    Used when SessionManager is not available
    """
{%- if 'GraphMailClient' in services %}
    if user_email:
        graph_mail_client.user_email = user_email

    if not getattr(graph_mail_client, "_initialized", False):
        initialized = await graph_mail_client.initialize(user_email=user_email)
        if not initialized:
            raise HTTPException(status_code=500, detail="Failed to initialize GraphMailClient")
{%- elif 'FileManager' in services %}
    # FileManager doesn't need special initialization in legacy mode
    # It's already initialized globally
    global file_manager
    if file_manager is None:
        file_manager = FileManager()
    logger.info(f"Using legacy file manager for user: {user_email or 'default'}")
{%- else %}
    # Implement initialization logic for your services here
    pass
{%- endif %}


async def get_user_session_or_legacy(user_email: str, access_token: Optional[str] = None):
    """
    Get session if SessionManager available, otherwise return legacy instances

    Args:
        user_email: User's email address
        access_token: Optional access token for authentication

    Returns:
        Session object or dict with legacy instances

    Raises:
        HTTPException: If initialization fails
    """
    if USE_SESSION_MANAGER:
        # Use SessionManager
        try:
            session = await session_manager.get_or_create_session(user_email, access_token)
            if not session.initialized:
{%- if 'FileManager' in services %}
                # Initialize file manager for this session
                session.file_manager = FileManager()
                session.metadata_manager = session.file_manager.metadata_manager
                session.initialized = True
                logger.info(f"Initialized file manager for session: {user_email}")
{%- else %}
                raise HTTPException(
                    status_code=500,
                    detail=f"Failed to initialize session for user: {user_email}"
                )
{%- endif %}
            return session
        except Exception as e:
            logger.error(f"Error getting session for {user_email}: {str(e)}")
            raise HTTPException(status_code=500, detail=str(e))
    else:
        # Legacy mode - return global instances wrapped in a dict
        await ensure_graph_mail_client_legacy(user_email)
        result = {
{%- for service, info in services.items() %}
            '{{ info.instance_name }}': {{ info.instance_name }},
{%- endfor %}
            'user_email': user_email
        }
{%- if 'FileManager' in services %}
        # Add metadata_manager from file_manager
        result['metadata_manager'] = file_manager.metadata_manager
{%- endif %}
        return result


def get_query_instance(context):
    """Get query service instance from session or legacy context"""
{%- if 'GraphMailQuery' in services %}
    return context.graph_mail_query if USE_SESSION_MANAGER else context['graph_mail_query']
{%- elif 'FileManager' in services %}
    return context.file_manager if USE_SESSION_MANAGER else context['file_manager']
{%- else %}
    # Adapt this helper for your service
    pass
{%- endif %}


def get_client_instance(context):
    """Get client service instance from session or legacy context"""
{%- if 'GraphMailClient' in services %}
    return context.graph_mail_client if USE_SESSION_MANAGER else context['graph_mail_client']
{%- elif 'FileManager' in services %}
    return context.file_manager if USE_SESSION_MANAGER else context['file_manager']
{%- elif 'MetadataManager' in services %}
    return context.metadata_manager if USE_SESSION_MANAGER else context['metadata_manager']
{%- else %}
    # Adapt this helper for your service
    pass
{%- endif %}


{%- if 'FileManager' in services %}
def get_file_manager_instance(context):
    """Get FileManager instance from session or legacy context"""
    return context.file_manager if USE_SESSION_MANAGER else context['file_manager']


def get_metadata_manager_instance(context):
    """Get MetadataManager instance from session or legacy context"""
    return context.metadata_manager if USE_SESSION_MANAGER else context['metadata_manager']
{%- endif %}


async def handle_token_error(e: Exception, user_email: str):
    """Handle token-related errors"""
    if USE_SESSION_MANAGER and ("401" in str(e) or "unauthorized" in str(e).lower()):
        await session_manager.invalidate_session(user_email)
        raise HTTPException(status_code=401, detail="Access token expired")
    raise e


# ============================================================
# Internal Args Support
# ============================================================
def extract_schema_defaults(arg_info: dict) -> dict:
    """Extract default values from original_schema.properties.

    These are the static defaults from UI/Pydantic/saved settings.
    """
    original_schema = arg_info.get("original_schema", {})
    properties = original_schema.get("properties", {})
    defaults = {}
    for prop_name, prop_def in properties.items():
        if "default" in prop_def:
            defaults[prop_name] = prop_def["default"]
    return defaults


def load_internal_args() -> dict:
    """Load internal args from tool_internal_args.json"""
    possible_paths = [
        os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "mcp_editor", "{{ module_name }}", "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tool_internal_args.json"),
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "tool_internal_args.json"),
    ]
    for path in possible_paths:
        if os.path.exists(path):
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    raw_args = json.load(f)
                logger.info(f"Loaded internal args from {path}")
                return raw_args
            except Exception as exc:
                logger.warning(f"Failed to load internal args from {path}: {exc}")
    return {}


INTERNAL_ARGS = load_internal_args()

INTERNAL_ARG_TYPES = {
    "FilterParams": FilterParams,
    "ExcludeParams": ExcludeParams,
    "SelectParams": SelectParams,
}


def build_internal_param(tool_name: str, arg_name: str, runtime_value: dict = None):
    """Instantiate internal parameter object for a tool.

    Value resolution priority:
    1. runtime_value (value): Dynamic value passed from function arguments at runtime
    2. default: Static value from original_schema.properties (UI/Pydantic/saved settings)

    Args:
        tool_name: Name of the tool
        arg_name: Name of the internal argument
        runtime_value: Optional runtime value passed from function call (value field)

    Returns:
        Instantiated parameter object or None
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return None

    param_cls = INTERNAL_ARG_TYPES.get(arg_info.get("type"))
    if not param_cls:
        logger.warning(f"Unknown internal arg type for {tool_name}.{arg_name}: {arg_info.get('type')}")
        return None

    # Get default values from original_schema.properties (static defaults)
    defaults = extract_schema_defaults(arg_info)

    # Get stored value field (may be set by previous runtime or config)
    stored_value = arg_info.get("value")

    # Priority: runtime_value > stored value > defaults
    if runtime_value is not None and runtime_value != {}:
        # Runtime value provided - merge with defaults (runtime takes precedence)
        final_value = {**defaults, **runtime_value}
        logger.debug(f"Using runtime value for {tool_name}.{arg_name}: {runtime_value}")
    elif stored_value is not None and stored_value != {}:
        # Stored value exists - merge with defaults (stored takes precedence)
        final_value = {**defaults, **stored_value}
        logger.debug(f"Using stored value for {tool_name}.{arg_name}: {stored_value}")
    else:
        # No value provided - use defaults only
        final_value = defaults
        logger.debug(f"Using defaults for {tool_name}.{arg_name}: {defaults}")

    if not final_value:
        # No values at all, use empty constructor
        return param_cls()

    try:
        return param_cls(**final_value)
    except Exception as exc:
        logger.warning(f"Failed to build internal arg {tool_name}.{arg_name}: {exc}")
        return None


def get_internal_arg_defaults(tool_name: str, arg_name: str) -> dict:
    """Get default values for an internal arg (from original_schema.properties).

    Use this to get the static defaults without instantiating the parameter.
    """
    arg_info = INTERNAL_ARGS.get(tool_name, {}).get(arg_name)
    if not arg_info:
        return {}
    return extract_schema_defaults(arg_info)


class MCPRequest(BaseModel):
    jsonrpc: str = "2.0"
    id: Optional[Any] = None
    method: str
    params: Optional[Dict[str, Any]] = {}


class MCPToolCall(BaseModel):
    name: str
    arguments: Dict[str, Any]


class MCPResponse(BaseModel):
    jsonrpc: str = "2.0"
    id: Optional[Any] = None
    result: Optional[Any] = None
    error: Optional[Dict[str, Any]] = None


@app.get("/sessions")
async def get_sessions_info():
    """Get information about active sessions"""
    if USE_SESSION_MANAGER:
        return session_manager.get_session_info()
    else:
        return {
            "message": "SessionManager not available - running in legacy mode",
            "mode": "legacy",
            "info": "All requests share global instances"
        }


@app.post("/")
async def handle_mcp_request(request: Request):
    """Main MCP protocol handler"""
    try:
        body = await request.json()
        mcp_request = MCPRequest(**body)

        # Route based on MCP method
        if mcp_request.method == "initialize":
            return handle_initialize(mcp_request)
        elif mcp_request.method == "tools/list":
            return handle_list_tools(mcp_request)
        elif mcp_request.method == "tools/call":
            return await handle_tool_call(mcp_request)
        else:
            return create_error_response(
                mcp_request.id,
                -32601,
                f"Method not found: {mcp_request.method}"
            )
    except Exception as e:
        return create_error_response(
            body.get("id") if "body" in locals() else None,
            -32603,
            f"Internal error: {str(e)}"
        )


def handle_initialize(request: MCPRequest) -> JSONResponse:
    """Handle MCP initialize request"""
    return JSONResponse(content={
        "jsonrpc": "2.0",
        "id": request.id,
        "result": {
            "protocolVersion": "0.1.0",
            "capabilities": {
                "tools": {}
            },
            "serverInfo": {
                "name": "outlook-mcp-server",
                "version": "1.0.0"
            }
        }
    })


def handle_list_tools(request: MCPRequest) -> JSONResponse:
    """Handle MCP tools/list request"""
    return JSONResponse(content={
        "jsonrpc": "2.0",
        "id": request.id,
        "result": {
            "tools": MCP_TOOLS
        }
    })


async def handle_tool_call(request: MCPRequest) -> JSONResponse:
    """Handle MCP tools/call request - routes to appropriate function"""
    try:
        tool_name = request.params.get("name")
        arguments = request.params.get("arguments", {})

        # Route to appropriate handler
        {%- for tool in tools %}
        {% if loop.first %}if{% else %}elif{% endif %} tool_name == "{{ tool.name }}":
            result = await handle_{{ tool.name }}(arguments)
        {%- endfor %}
        else:
            return create_error_response(
                request.id,
                -32602,
                f"Unknown tool: {tool_name}"
            )

        return JSONResponse(content={
            "jsonrpc": "2.0",
            "id": request.id,
            "result": {
                "content": [
                    {
                        "type": "text",
                        "text": json.dumps(result, indent=2)
                    }
                ]
            }
        })
    except Exception as e:
        return create_error_response(
            request.id,
            -32603,
            f"Tool execution error: {str(e)}"
        )


# Tool handler functions - routing to session-specific implementations
{%- for tool in tools %}

async def handle_{{ tool.name }}(args: Dict[str, Any]) -> Dict[str, Any]:
    """Route to {{ tool.service_class }}.{{ tool.service_method }} with session or legacy support"""
    user_email = args["user_email"]

    # Get session or legacy instances
    context = await get_user_session_or_legacy(user_email, args.get("access_token"))

    {%- if tool.object_params %}

    # Extract parameters from args
    {%- for param_name, param_info in tool.params.items() if param_name != 'user_email' %}
    {%- if param_info.is_required %}
    {{ param_name }} = args["{{ param_name }}"]
    {%- elif param_info.has_default %}
    # Optional with default: use default if LLM didn't provide value
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
    {%- else %}
    {{ param_name }} = args.get("{{ param_name }}")
    {%- endif %}
    {%- endfor %}

    # Convert dicts to parameter objects where needed (Signature params from args)
    {%- for param_name, param_info in tool.object_params.items() %}
    {%- if param_name not in tool.internal_args %}
    {#- Required parameter - must be provided by LLM #}
    {%- if not param_info.is_optional %}
    {{ param_name }}_params = {{ param_info.class_name }}(**args["{{ param_name }}"])
    {#- Optional parameter with default value (use is not None to accept empty objects/arrays) #}
    {%- elif param_info.has_default %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    if {{ param_name }}_raw is not None:
        # LLM provided a value (even empty {} or [] is valid)
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_raw)
    else:
        # LLM didn't provide value - use default from web editor
        {%- if param_info.default_json %}
        {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_info.default_json }})
        {%- else %}
        # Explicit null default or no default value
        {{ param_name }}_params = None
        {%- endif %}
    {#- Optional parameter without default #}
    {%- else %}
    {{ param_name }}_raw = args.get("{{ param_name }}")
    {{ param_name }}_params = {{ param_info.class_name }}(**{{ param_name }}_raw) if {{ param_name }}_raw is not None else None
    {%- endif %}
    {%- endif %}
    {%- endfor %}
    {%- if tool.internal_args %}

    # Internal Args (pre-configured defaults, not exposed to MCP signature)
    {%- for arg_name, arg_info in tool.internal_args.items() %}
    {%- if arg_info.value is none %}
    # {{ arg_name }}: None - parameter not passed
    {{ arg_name }}_params = None
    {%- elif arg_info.value == {} %}
    # {{ arg_name }}: empty object - use default constructor
    {{ arg_name }}_params = {{ arg_info.type }}()
    {%- else %}
    # {{ arg_name }}: pre-configured default value
    {{ arg_name }}_params = {{ arg_info.type }}(**{{ arg_info.value | pprint }})
    {%- endif %}
    {%- endfor %}
    {%- endif %}

    try:
        # Use helper to get the correct instance
        {%- if 'query' in (tool.mcp_service or tool.service_method or '').lower() %}
        service_instance = get_query_instance(context)
        {%- else %}
        service_instance = get_client_instance(context)
        {%- endif %}

        return await service_instance.{{ tool.mcp_service or tool.service_method }}(
            user_email=user_email,
            {%- for param_name, param_info in tool.call_params.items() if param_name != 'user_email' %}
            {{ param_name }}={{ param_info.value }}{{ "," if not loop.last else "" }}
            {%- endfor %}
        )
    except Exception as e:
        await handle_token_error(e, user_email)
    {%- else %}

    try:
        # Use helper to get the correct instance
        {%- if 'query' in (tool.mcp_service or tool.service_method or '').lower() %}
        service_instance = get_query_instance(context)
        {%- else %}
        service_instance = get_client_instance(context)
        {%- endif %}

        {#- Extract parameters with proper default handling #}
        {%- for param_name, param_info in tool.params.items() %}
        {%- if param_info.is_required %}
        {{ param_name }} = args["{{ param_name }}"]
        {%- elif param_info.has_default %}
        # Optional with default: use default if LLM didn't provide value
        {{ param_name }}_raw = args.get("{{ param_name }}")
        {{ param_name }} = {{ param_name }}_raw if {{ param_name }}_raw is not None else {{ param_info.default_json }}
        {%- else %}
        {{ param_name }} = args.get("{{ param_name }}")
        {%- endif %}
        {%- endfor %}

        return await service_instance.{{ tool.mcp_service or tool.service_method }}(
            {%- for param_name, param_info in tool.params.items() %}
            {{ param_name }}={{ param_name }}{{ "," if not loop.last else "" }}
            {%- endfor %}
        )
    except Exception as e:
        await handle_token_error(e, user_email)
    {%- endif %}
{%- endfor %}


def create_error_response(id: Any, code: int, message: str) -> JSONResponse:
    """Create MCP error response"""
    return JSONResponse(content={
        "jsonrpc": "2.0",
        "id": id,
        "error": {
            "code": code,
            "message": message
        }
    })


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=3000)