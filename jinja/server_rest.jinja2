# ============================================================
# REST API Protocol Handlers for MCP
# ============================================================

app = FastAPI(title="{{ server_title | default(server_name | title + ' MCP Server') }}", version="1.0.0")


@app.on_event("startup")
async def startup_event():
    """Initialize services on server startup"""
{%- for service_name, service_info in services.items() %}
    if hasattr({{ service_info.instance }}, 'initialize'):
        await {{ service_info.instance }}.initialize()
        logger.info("{{ service_info.class_name }} initialized")
{%- endfor %}
    logger.info("{{ server_title | default(server_name | title + ' MCP Server') }} started")


@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on server shutdown"""
    logger.info("{{ server_title | default(server_name | title + ' MCP Server') }} stopped")


@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "name": "{{ server_title | default(server_name | title + ' MCP Server') }}",
        "version": "1.0.0"
    }


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "server": "{{ server_name }}"}


@app.post("/mcp/v1/initialize")
async def initialize(request: Request):
    """Initialize MCP session"""
    body = await request.json()
    return {
        "protocolVersion": "1.0",
        "serverInfo": {
            "name": "{{ server_name }}-mcp-server",
            "version": "1.0.0"
        },
        "capabilities": {
            "tools": {}
        }
    }


@app.post("/mcp/v1/tools/list")
async def list_tools(request: Request):
    """List available MCP tools"""
    try:
        # Get tools metadata
        tools_list = []
        for tool in MCP_TOOLS:
            tools_list.append({
                "name": tool["name"],
                "description": tool.get("description", ""),
                "inputSchema": tool.get("inputSchema", {})
            })

        return JSONResponse(content={
            "result": {
                "tools": tools_list
            }
        })
    except Exception as e:
        logger.error(f"Error listing tools: {e}")
        return JSONResponse(
            status_code=500,
            content={"error": {"message": str(e)}}
        )


@app.post("/mcp/v1/tools/call")
async def call_tool(request: Request):
    """Execute an MCP tool"""
    try:
        data = await request.json()
        tool_name = data.get("name")
        arguments = data.get("arguments", {})

        logger.info(f"Tool call: {tool_name} with args: {arguments}")

        implementation_info = get_tool_implementation(tool_name)
        if not implementation_info:
            return JSONResponse(
                status_code=404,
                content={"error": {"message": f"Unknown tool: {tool_name}"}}
            )

        # Get service instance by class name
        service_class = implementation_info["service_class"]
        service_instance = get_service_instance(service_class)

        if not service_instance:
            return JSONResponse(
                status_code=500,
                content={"error": {"message": f"Service not available: {service_class}"}}
            )

        # Get the method
        method_name = implementation_info["method"]
        method = getattr(service_instance, method_name, None)
        if not method:
            return JSONResponse(
                status_code=500,
                content={"error": {"message": f"Method not found: {method_name}"}}
            )

        # Process arguments based on tool configuration
        # Handle parameter transformations
        processed_args = {}

        # Get tool configuration
        tool_config = get_tool_config(tool_name)

        if tool_config:
            schema_props = tool_config.get("inputSchema", {}).get("properties", {})
            tool_internal_args = INTERNAL_ARGS.get(tool_name, {})

            # Process signature arguments
            for param_name, param_value in arguments.items():
                param_schema = schema_props.get(param_name, {})

                # Transform object parameters to their expected types
                if param_schema.get("type") == "object":
                    base_model = param_schema.get("baseModel")
                    target_param = param_schema.get("targetParam", param_name)  # Use targetParam if specified

                    # Create object instance based on baseModel
                    # Skip empty dicts - they should be treated as None for merging with internal args
                    if base_model and base_model in globals():
                        model_class = globals()[base_model]
                        if param_value:  # Only create object if param_value is not empty/None
                            processed_args[target_param] = model_class(**param_value)
                        # If empty, don't add to processed_args - let internal args take over
                    elif param_value:  # Only add non-empty values
                        processed_args[target_param] = param_value
                else:
                    # For non-object types, check if there's a targetParam mapping
                    target_param = param_schema.get("targetParam", param_name)
                    processed_args[target_param] = param_value

            # Process internal arguments
            for arg_name, arg_info in tool_internal_args.items():
                # Check if this internal arg has a targetParam
                target_param = arg_info.get("targetParam", arg_name)

                # Build internal parameter
                internal_value = build_internal_param(tool_name, arg_name)

                if internal_value is not None:
                    # Check if target_param already exists from signature args
                    if target_param in processed_args:
                        # Signature args have priority - merge internal into signature
                        sig_value = processed_args[target_param]

                        # If both are objects, merge them (signature priority)
                        if hasattr(sig_value, '__dict__') and hasattr(internal_value, '__dict__'):
                            # Convert to dict for merging (exclude None values)
                            sig_dict = {k: v for k, v in vars(sig_value).items() if v is not None}
                            internal_dict = {k: v for k, v in vars(internal_value).items() if v is not None}

                            # Merge with signature priority
                            merged_dict = {**internal_dict, **sig_dict}

                            # Recreate object with merged values
                            param_type = type(sig_value)
                            processed_args[target_param] = param_type(**merged_dict)
                        # Otherwise keep signature value (signature priority)
                    else:
                        # No signature arg, use internal arg
                        processed_args[target_param] = internal_value
        else:
            processed_args = arguments

        # Call the method
        result = await method(**processed_args)

        response_content = format_tool_result(result)
        return JSONResponse(content=build_mcp_content(response_content))

    except aiohttp.ClientResponseError as e:
        # HTTP-level errors from external API calls
        logger.error(f"API error executing tool {tool_name}: {e.status} {e.message}", exc_info=True)
        if e.status == 401:
            return JSONResponse(
                status_code=401,
                content={"error": {"code": "AUTH_EXPIRED", "message": "Access token expired or invalid. Re-authentication required."}}
            )
        elif e.status == 403:
            return JSONResponse(
                status_code=403,
                content={"error": {"code": "PERMISSION_DENIED", "message": "Insufficient permissions for this operation."}}
            )
        elif e.status == 404:
            return JSONResponse(
                status_code=404,
                content={"error": {"code": "NOT_FOUND", "message": f"Resource not found: {e.message}"}}
            )
        elif e.status == 429:
            return JSONResponse(
                status_code=429,
                content={"error": {"code": "RATE_LIMITED", "message": "API rate limit exceeded. Please retry later."}}
            )
        else:
            return JSONResponse(
                status_code=e.status,
                content={"error": {"code": "API_ERROR", "message": str(e)}}
            )
    except HTTPException as e:
        # FastAPI HTTP exceptions (pass through)
        logger.error(f"HTTP error executing tool {tool_name}: {e.status_code} {e.detail}", exc_info=True)
        return JSONResponse(
            status_code=e.status_code,
            content={"error": {"code": "HTTP_ERROR", "message": e.detail}}
        )
    except Exception as e:
        # Check for auth-related keywords in generic exceptions
        error_str = str(e).lower()
        if "401" in error_str or "unauthorized" in error_str or "token expired" in error_str:
            logger.error(f"Auth error executing tool {tool_name}: {e}", exc_info=True)
            return JSONResponse(
                status_code=401,
                content={"error": {"code": "AUTH_EXPIRED", "message": "Authentication failed. Re-authentication required."}}
            )
        elif "403" in error_str or "forbidden" in error_str or "permission" in error_str:
            logger.error(f"Permission error executing tool {tool_name}: {e}", exc_info=True)
            return JSONResponse(
                status_code=403,
                content={"error": {"code": "PERMISSION_DENIED", "message": "Permission denied."}}
            )

        # General internal error
        logger.error(f"Error executing tool {tool_name}: {e}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content={"error": {"code": "INTERNAL_ERROR", "message": str(e)}}
        )
